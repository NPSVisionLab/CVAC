/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                        Intel License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000, Intel Corporation, all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of Intel Corporation may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

/*
 * performance.cpp
 *
 * Measure performance of classifier
 */
#include <Ice/Ice.h>
#include <IceBox/IceBox.h>
#include <IceUtil/UUID.h>
#include "DetectorI.h"
#include <CVACUtil/processRunSet.h>
#include <CVACUtil/FileUtils.h>
#include <CVACUtil/DetectorDataArchive.h>
#include "opencv2/opencv.hpp"
#include "opencv2/highgui/highgui.hpp"

#include <cstdio>
#include <cmath>
#include <ctime>
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
/* use clock() function instead of time() */
#define time( arg ) (((double) clock()) / CLOCKS_PER_SEC)
#endif /* _WIN32 */

using namespace Ice;
using namespace cvac;

#ifndef PATH_MAX
#define PATH_MAX 512
#endif /* PATH_MAX */

typedef struct HidCascade
{
    int size;
    int count;
} HidCascade;

typedef struct ObjectPos
{
    float x;
    float y;
    float width;
    int found;    /* for reference */
    int neighbors;
} ObjectPos;

//===========================================================================

static const char *configFile = "config.server";

//===========================================================================

// For Use with IceBox service
class CVAC_OpenCV_Detector : public ::IceBox::Service
{
private:
    Ice::ObjectAdapterPtr _adapter;
    std::string mName;
public:
    CVAC_OpenCV_Detector()
    {

    }
    virtual ~CVAC_OpenCV_Detector()
    {
    }
    virtual void start(const std::string& name,
        const Ice::CommunicatorPtr &communicator,
        const Ice::StringSeq &args)
    {
        mName = name;
        _adapter = communicator->createObjectAdapter(name);

        DetectorI* detect = new DetectorI("opencv_ak-47",
                                          "OpenCV HAAR detector for AK-47",
                                          "LeftHalfCascade01_000_14.xml");
        _adapter->add(detect, communicator->stringToIdentity("CVAC_OpenCV_Detector"));
        _adapter->activate();

        std::cout << "|Service started|: " << mName << std::endl;
    }

    virtual void stop()
    {
        std::cout << "|Service stopped|: " << mName << std::endl;
        _adapter->destroy();
    }
};
// factory function for IceBox server
extern "C"
{
    ICE_DECLSPEC_EXPORT IceBox::Service* create(Ice::CommunicatorPtr communicator)
    {
        return new CVAC_OpenCV_Detector();
    }
}
//===========================================================================



class OpenCVPerformanceServer : public Ice::Application
{
public:
    virtual int run(int, char*[]);
};

int main( int argc, char* argv[] )
{
     OpenCVPerformanceServer app;
     return app.main(argc, argv, configFile);
}

int OpenCVPerformanceServer::run( int argc, char* [] )
{
    if(argc > 1)
    {
        std::cerr << appName() << ": too many arguments" << std::endl;
        return EXIT_FAILURE;
    }

    Ice::ObjectAdapterPtr adapter =
           communicator()->createObjectAdapter("CVAC_OpenCV_Detector.Server");


  /*Ice::Identity alID = communicator()->stringToIdentity(IceUtil::generateUUID());
    CVAlgorithmPrx alProx = CVAlgorithmPrx::uncheckedCast(adapter->createProxy(alID));
    adapter->add(algor, alID);*/

    DetectorI* detect = new DetectorI("opencv_ak-47",
                              "OpenCV HAAR detector for AK-47",
                               "LeftHalfCascade01_000_14.xml");
    adapter->add(detect,
                 communicator()->stringToIdentity("CVAC_OpenCV_Detector"));

    adapter->activate();

    communicator()->waitForShutdown();
    return EXIT_SUCCESS;
}

//===========================================================================

ResultSetV2 detectFile(DetectorPtr detector, const char *fname)
{
   ResultSetV2 resultSet;

   IplImage* img;
   double scale_factor = 1.2;
   int i;
   DetectorI *detectI = dynamic_cast<DetectorI*>(detector.get());

   img = cvLoadImage( fname );
   if( !img )
   {
      return resultSet;
   }

   CvMemStorage *storage = detectI->getStorage();
   CvHaarClassifierCascade *cascade = detectI->getCascade();
   cvClearMemStorage(storage);
   CvSeq *objects;
   objects = cvHaarDetectObjects(img, cascade, storage, scale_factor, 1 );
   cascade->count = detectI->getNOS();

   int detcount = ( objects ? objects->total : 0);

   Result newResult;
   newResult.original = new Labelable();
   newResult.original->sub.isImage = true;
   newResult.original->sub.path.filename = std::string(fname);
   newResult.original->sub.path.directory.relativePath = std::string(cvac::getCurrentWorkingDirectory().c_str());


   //res.filename = std::string(fname);

   //ResultRect rect;
   //std::vector<ResultRect> *detections =
      //new std::vector<ResultRect>(detcount);
   for( i = 0; i < detcount; i++ )
   {
      CvAvgComp r = *((CvAvgComp*) cvGetSeqElem( objects, i ));

      BBox* box = new BBox();
      box->x = r.rect.x;
      box->y = r.rect.y;
      box->width = r.rect.width;
      box->height = r.rect.height;

      LabeledLocation* newLocation = new LabeledLocation();
      newLocation->loc = box;

      newResult.foundLabels.push_back(newLocation);
      //detections->push_back(rect);
   }

   resultSet.results.push_back(newResult);

   //res.filename = std::string(fname);
   //res.detections = *detections;

   cvReleaseImage( &img );

   return resultSet;
}

/*
ResultSetV1 detectFile(DetectorPtr detector, const char *fname)
{
    ResultSetV1 res;
    IplImage* img;
    double scale_factor = 1.2;
    int i;
    DetectorI *detectI = dynamic_cast<DetectorI*>(detector.get());

    img = cvLoadImage( fname );
    if( !img )
    {
        return res;
    }
    CvMemStorage *storage = detectI->getStorage();
    CvHaarClassifierCascade *cascade = detectI->getCascade();
    cvClearMemStorage(storage);
    CvSeq *objects;
    objects = cvHaarDetectObjects(img, cascade, storage, scale_factor, 1 );
    cascade->count = detectI->getNOS();

    int detcount = ( objects ? objects->total : 0);

    res.filename = std::string(fname);
    ResultRect rect;
     std::vector<ResultRect> *detections =
                         new std::vector<ResultRect>(detcount);
    for( i = 0; i < detcount; i++ )
    {
        CvAvgComp r = *((CvAvgComp*) cvGetSeqElem( objects, i ));
        rect.x = r.rect.x;
        rect.y = r.rect.y;
        rect.width = r.rect.width;
        rect.height = r.rect.height;
        rect.confidence = 0;
        detections->push_back(rect);
    }

    res.filename = std::string(fname);
    res.detections = *detections;

    cvReleaseImage( &img );

    return res;
}
*/

//===========================================================================
DetectorI::DetectorI(std::string name, std::string desc, std::string cascade)
{
    _cascadeString = cascade;
    _name = name;
    _description = desc;
    _is_initialized = false;
    _verbosity = 0;
}

const char *tempSavedCascade = "mycascade";  // temp binary file name
#ifdef WIN32
const char *openStr = "w+b";
#else
const char *openStr = "w+";
#endif

void DetectorI::initialize(int verbosity,
                           const ::cvac::DetectorData& ddata,
                           const Ice::Current &current)
{
    bool newCascade = false;
    _verbosity = verbosity;
    setDDAVerbosity(verbosity); // Set the printv level of the Ice DetectorDataArchive module
    _ddata = ddata;
    _storage = cvCreateMemStorage();
    int size = ddata.data.size();
    std::string arg1;
    ::FILE *xml = NULL;
    std::string archiveFilePath;


    // Load the CVAC property: 'CVAC.DataDir'.  Used for the xml filename path, and to correct Runset paths
    Ice::PropertiesPtr props = (current.adapter->getCommunicator()->getProperties());
    m_CVAC_DataDir = props->getProperty("CVAC.DataDir");
    if(m_CVAC_DataDir.empty()) {
      std::cerr << std::endl << "Unable to locate CVAC Data directory, specified: 'CVAC.DataDir = path/to/dataDir' in </CVAC_Services/config.service>" << std::endl << std::endl;
    }
    
    if (size > 0 || ddata.type == cvac::FILE) // A file name and path object was received
    {
      if(cvac::FILE == ddata.type && size == 0) 
      {
        // Use utils un-compression to get file names
        std::string directory = std::string(cvac::getCurrentWorkingDirectory().c_str());  // Unzip to subfolder of CWD, not CVAC_DataDir
        std::string name = getName(current);
        std::string dpath;
        dpath.reserve(directory.length() + name.length() + 3);
        dpath += directory;
        dpath += std::string("/");
        dpath += ".";
        dpath += name;  // Filepath is relative to 'CVAC_DataDir'
        if ((ddata.file.directory.relativePath.length() > 1 && ddata.file.directory.relativePath[1] == ':' )||
            ddata.file.directory.relativePath[0] == '/' ||
            ddata.file.directory.relativePath[0] == '\\')
        {  // absolute path
            archiveFilePath = ddata.file.directory.relativePath + "/" + ddata.file.filename;
        } else { // prepend our prefix
            archiveFilePath = (m_CVAC_DataDir + "/" + ddata.file.directory.relativePath + "/" + ddata.file.filename);
        }
        std::vector<std::string> fileNameStrings =  expandSeq_fromFile(archiveFilePath, name);

        // Expecting 1 argument
        int numFilesInVector = (int)fileNameStrings.size();
        if(1 != numFilesInVector) {
          std::cerr << "Expected 1 xml file from zip, (plus one txt file), got: " << numFilesInVector << std::endl;
          std::cerr << "Not inititializing. " << std::endl;
        }
        arg1 = dpath;
        arg1 += std::string("/");
        arg1 += std::string(fileNameStrings.back());
        
        if(verbosity >=4) {  // 'info' message
          std::cout << "CvPerformance Detector extracted XML Filename from archive of:  " << std::endl << arg1 << std::endl;
        }
        _cascadeString = arg1;
      }
      else if(cvac::BYTES == ddata.type)
      {
        xml = fopen(tempSavedCascade, openStr);

        if (NULL == xml)
        {
          std::cerr << "Error in 'DetectorI::initialize(..', failed to create xml cascade on disk from ddata." << std::endl;
          return;
        }
      }
      else if(cvac::FILE == ddata.type)
      {
        xml = fopen(arg1.c_str(), openStr);

        if (NULL == xml)
        {
          std::cerr << "Error in 'DetectorI::initialize(..', failed to open xml cascade from zip." << std::endl;
          return;
        }
        else {
          if(verbosity >=3) {
            std::cout << "CvPerformance Detector loaded XML file.  " << std::endl;
          }
        }
      }
      if (xml != NULL)
      {
         // Proceed to access XML
         char *buff = new char[size];
         int i;
         for (i = 0; i < size; i++)
           buff[i] = ddata.data[i];
         int res = fwrite(buff, 1, size, xml);
         delete buff;
         if (res != size)
         {
           //GenericError e;
           //e.reason = "Could not write temporary cascade file";
           //throw e;

           std::cerr << "Error in 'DetectorI::initialize(..',  '(res != size)', 'Could not write temporary cascade file'." << std::endl;
           return;
         }
         fflush(xml);
         fclose(xml);
         newCascade = true;
       }
    }
    else {
      std::cerr << "Error in 'DetectorI::initialize(..', Received 'ddata' stream with size of 0." << std::endl;
    }

    if (_cascadeString.size() > 0 && newCascade == false)
    {
      _cascade = cvLoadHaarClassifierCascade(
        _cascadeString.c_str(), cvSize( DetectorI::SCAN_WIDTH,
        DetectorI::SCAN_HEIGHT ) );
    }else
    {
      _cascade = cvLoadHaarClassifierCascade(
        tempSavedCascade, cvSize( DetectorI::SCAN_WIDTH,
        DetectorI::SCAN_HEIGHT ) );
    }
    if (NULL != _cascade)
    {
      _nos = _cascade->count;
      _is_initialized = true;
    }
}

///////////////////////////////////////////////////////////////////////////////
cvac::DetectorData DetectorI::createCopyOfDetectorData(const ::Ice::Current& current)
{
   return _ddata;
}

DetectorI::~DetectorI()
{
}


void DetectorI::destroy(const Ice::Current &current)
{
    _is_initialized = false;
    if (NULL != _storage)
        cvReleaseMemStorage( &_storage );
    if (NULL != _cascade)
        cvReleaseHaarClassifierCascade( &_cascade );
}


void DetectorI::process(const DetectorCallbackHandlerPrx &client,
                        const RunSet &run,
                        const Ice::Current &)
{
/*  NOT SURE HOW TO DO THIS PROPERLY
  // First iterate through file-lists in the RunSet, add prefix-path
  std::vector<PurposedListPtr>::iterator it;
  std::vector<PurposedListPtr> plist = run.purposedLists;

  for (it = plist.begin(); it < plist.end(); it++)
  {
    PurposedListPtr p = (*it);
    PurposedLabelableSeqPtr sp = PurposedLabelableSeqPtr::dynamicCast(p);
    PurposedDirectoryPtr dirptr = PurposedDirectoryPtr::dynamicCast(p);

    if (sp) // each file-list
    {
      std::vector<LabelablePtr>::iterator lIt;
      std::vector<LabelablePtr> llist = sp->labeledArtifacts;
      for (lIt = llist.begin(); lIt < llist.end(); lIt++)
      {
        LabelablePtr lptr = *lIt;
        Substrate sub = lptr->sub;
        FilePath  filePath = sub.path; // Path insertion performed in-place on filename
        std::string fname = (filePath.directory.relativePath);
        fname += std::string("/");
        fname += filePath.filename;
      }
    }
  }
*/
  _callback = client;
  DoDetectFunc func = detectFile;
  processRunSet(this, client, func, run, m_CVAC_DataDir); // Runs 'func' with modified runset-paths based on data dir
}

DetectorPropertiesPrx DetectorI::getDetectorProperties(const Ice::Current &)
{
    return NULL;
}

bool DetectorI::isInitialized(const Ice::Current &)
{
    return _is_initialized;
}


std::string DetectorI::getName( const Ice::Current &)
{
    return _name;
}
std::string DetectorI::getDescription(const Ice::Current &)
{
    return _description;
}
void DetectorI::setVerbosity(int verbosity, const Ice::Current &)
{
    _verbosity = verbosity;
}
