#include "bowICEI.h"
#include <iostream>
#include <vector>

#include <Ice/Communicator.h>
#include <Ice/Initialize.h>
#include <Ice/ObjectAdapter.h>
#include <CVACUtil/processRunSet.h>
#include <CVACUtil/FileUtils.h>
#include <CVACUtil/DetectorDataArchive.h>

bowICEI::bowICEI()
: pBowCV(NULL),fInitialized(false),prmThresholdScore(0.9f)
{
	pBowCV = new bowCV();
}

bowICEI::~bowICEI()
{
	delete pBowCV;
	pBowCV = NULL;
}

void bowICEI::initialize(::Ice::Int verbosity,const ::cvac::DetectorData& data,const ::Ice::Current& current)
{
    int size = data.data.size();
    // Load the CVAC property: 'CVAC.DataDir'.  Used for the xml filename path, and to correct Runset paths
    Ice::PropertiesPtr props = (current.adapter->getCommunicator()->getProperties());
    m_CVAC_DataDir = props->getProperty("CVAC.DataDir");
    if(m_CVAC_DataDir.empty()) {
      std::cerr << std::endl << "Unable to locate CVAC Data directory, specified: 'CVAC.DataDir = path/to/dataDir' in </CVAC_Services/config.service>" 
                             << std::endl << std::endl;
    }

	if (!data.data.empty())
	{ 
        cvac::ByteSeq byteSeq = data.data;

		Ice::InputStreamPtr input = Ice::createInputStream(current.adapter->getCommunicator(), byteSeq);
    
		//////////////////////////////////////////////////////////////////////////
		// Setup: Detector, Extractor, Matcher, # of Clusters
		std::vector<std::string> strSeq;
		input->read(strSeq);
		//0: threshold
		//1: directory including the file "logTrain_Table.txt"
		
		std::cout << "Initializing Bag_of_Words Detector with: " << std::endl;
		std::cout << "Threshold Score = "<< strSeq[0] << std::endl;
		std::cout << "Directory including the file logTrain_Table.txt: " << strSeq[1] << endl;		

		if(pBowCV->detect_initialize(strSeq[1],logBowTrainResult))
		{
			prmThresholdScore = float(atof(strSeq[0].c_str()));
			fInitialized = true;
		}
		else
			fInitialized = false;
    }else if (cvac::FILE == data.type && size == 0)
    { // we have a zip filename being passed in
         // Use utils un-compression to get zip file names
         // Filepath is relative to 'CVAC_DataDir'
        std::string archiveFilePath; 
        if ((data.file.directory.relativePath.length() > 1 && data.file.directory.relativePath[1] == ':' )||
            data.file.directory.relativePath[0] == '/' ||
            data.file.directory.relativePath[0] == '\\')
        {  // absolute path
            archiveFilePath = data.file.directory.relativePath + "/" + data.file.filename;
        } else { // prepend our prefix
            archiveFilePath = (m_CVAC_DataDir + "/" + data.file.directory.relativePath + "/" + data.file.filename);
        }

         std::vector<std::string> fileNameStrings =  expandSeq_fromFile(archiveFilePath, getName(current));
		   // TODO add getting the threshold value from the detector properties but for now
         // hard code the value
         float thresHold = 0.9f;
         // Need to strip off extra zeros
         std::string directory = std::string(cvac::getCurrentWorkingDirectory().c_str());
         std::string name = getName(current);
         std::string dpath;
         dpath.reserve(directory.length() + name.length() + 3);
         dpath += directory;
         dpath += std::string("/");
         dpath += ".";
         dpath += name;
         
         if(pBowCV->detect_initialize(dpath,logBowTrainResult))
	      {
		      prmThresholdScore = thresHold;
		      fInitialized = true;
	      }
	      else
			   fInitialized = false;
    }

		
// 		if(pBowCV->initialize(strSeq[0],strSeq[1],strSeq[2],atoi(strSeq[3].c_str())))
// 		{
// 			if(pBowCV->readTrainResult(strSeq[5],logBowTrainResult))	// need to update (lekomin)
// 			{
// 				prmThresholdScore = float(atof(strSeq[4].c_str()));
// 				fInitialized = true;
// 			}
// 			else
// 				fInitialized = false;
// 		}
// 		else
// 			fInitialized = false;
}



bool bowICEI::isInitialized(const ::Ice::Current& current)
{
	return fInitialized;
}

void bowICEI::destroy(const ::Ice::Current& current)
{
	if(pBowCV != NULL)
		delete pBowCV;
	pBowCV = NULL;

	fInitialized = false;
}
std::string bowICEI::getName(const ::Ice::Current& current)
{
	return "bow";
}
std::string bowICEI::getDescription(const ::Ice::Current& current)
{
	return "BOW - Empty Description";
}

void bowICEI::setVerbosity(::Ice::Int verbosity, const ::Ice::Current& current)
{

}

cvac::DetectorData bowICEI::createCopyOfDetectorData(const ::Ice::Current& current)
{
	// need to update (lekomin)
	cvac::DetectorData data;
	return data;
}

cvac::DetectorPropertiesPrx bowICEI::getDetectorProperties(const ::Ice::Current& current)
{
	// need to update (lekomin)
	return NULL;
}

cvac::ResultSetV2 bowICEI::processSingleImg(cvac::DetectorPtr detector,const char* fullfilename)
{
	// need to update (lekomin): classID, confidence
	cvac::ResultSetV2 _resSet;	
	int _bestClass;
	float _bestScore; 	

	std::string _ffullname = std::string(fullfilename);
	std::cout << "===========================================" << std::endl;
	std::cout << _ffullname << " is processing" << std::endl;
	
	bowICEI* _bowCV = static_cast<bowICEI*>(detector.get());
 	_bowCV->pBowCV->detect_run(fullfilename,_bowCV->prmThresholdScore,_bestClass,_bestScore);
  	std::cout << _ffullname << " is Class " << _bestClass << std::endl;
	std::cout << "===========================================" << std::endl;

	cvac::Result _tResult;
	_tResult.original = new cvac::Labelable();
	//_tResult.original->confidence = _bestScore;
	_tResult.original->sub.path.filename = _ffullname;
   // The original field is for the original file name.  Results need
   // to be returned in foundLabels.
   cvac::Labelable *labelable = new cvac::Labelable();
   char buff[32];
   sprintf(buff, "%d", _bestClass);
   labelable->lab.name = buff;
   labelable->confidence = _bestScore;
   _tResult.foundLabels.push_back(labelable);

 	_resSet.results.push_back(_tResult);	
	
	return _resSet;
}

void bowICEI::process(const ::cvac::DetectorCallbackHandlerPrx& callbackHandler,const ::cvac::RunSet& runset,const ::Ice::Current& current)
{
	cvac::DoDetectFunc func = bowICEI::processSingleImg;
	cvac::processRunSet(this, callbackHandler, func, runset, m_CVAC_DataDir);
}
