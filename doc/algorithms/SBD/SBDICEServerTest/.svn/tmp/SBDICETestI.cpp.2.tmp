#include "SBDICETestI.h"
#include <iostream>
#include <vector>

#include <Ice/Communicator.h>
#include <Ice/Initialize.h>
#include <Ice/ObjectAdapter.h>
#include <CVACUtil/processRunSet.h>
#include <CVACUtil/FileUtils.h>
#include <CVACUtil/DetectorDataArchive.h>

std::string SBDICETestI::m_CVAC_DataDir = ""; // Stored on initilization of Detector
int SBDICETestI::m_verbosity = 0; // Implementation of static class variable

SBDICETestI::SBDICETestI()
: pSBDCV(NULL),fInitialized(false)
{
	pSBDCV = new SBDCV();
}

SBDICETestI::~SBDICETestI()
{
	delete pSBDCV;
	pSBDCV = NULL;
}

void SBDICETestI::initialize(::Ice::Int verbosity, const ::cvac::DetectorData& data, const ::Ice::Current& current)
{
	m_verbosity = (int)verbosity; // Save verbosity state within SBDICETestI
	int size = data.data.size();

	// Load the CVAC property: 'CVAC.DataDir'.  Used for the svm filename path, and to correct Runset paths
	Ice::PropertiesPtr props = (current.adapter->getCommunicator()->getProperties());
	m_CVAC_DataDir = props->getProperty("CVAC.DataDir");
	if(m_CVAC_DataDir.empty()) 
	{
		std::cerr << std::endl << "Unable to locate CVAC Data directory, specified: 'CVAC.DataDir = path/to/dataDir' in </CVAC_Services/config.service>"<< std::endl << std::endl;
	}
  
	if (!data.data.empty())
	{

		//////////////////////////////////////////////////////////////////////////
		// Setup: loading the SVM result
		cvac::ByteSeq byteSeq = data.data;
		Ice::InputStreamPtr input = Ice::createInputStream(current.adapter->getCommunicator(), byteSeq);
		std::vector<std::string> strSeq;
		input->read(strSeq);	 //0: directory including the file "svm_Result.xml.gz"

		//detectorData.file.directory.relativePath = std::string(argv[2]);
		//detectorData.file.filename = std::string(argv[3]);

		if(m_verbosity >= 2)
		{	
			// ToDo: Use full printv function
			std::cout << "Initializing Shot Boundary Detection with: " << data.file.directory.relativePath << "/" << data.file.filename << std::endl;		
			// std::cout << "Directory including the file svm_Result.xml.gz: " << strSeq[0] << endl;
		}

		cout << "in this function" << endl;
		//if(pSBDCV->test_loadSVM(strSeq[0],svmResult_xml))
		if(pSBDCV->test_loadSVM(data.file.directory.relativePath,data.file.filename))
		{			
			fInitialized = true;
		}
		else
		{
			fInitialized = false;
		}
	}
	else if (cvac::FILE == data.type && size == 0)
	{ // we have a zip filename being passed in
		// Use utils un-compression to get extracted file names
		std::string archiveFilePath; 
		if ((data.file.directory.relativePath.length() > 1 && data.file.directory.relativePath[1] == ':' )||
			data.file.directory.relativePath[0] == '/' ||
			data.file.directory.relativePath[0] == '\\')
		{  // absolute path
			archiveFilePath = data.file.directory.relativePath + "/" + data.file.filename;
		}
		else
		{ // prepend our prefix
			archiveFilePath = (m_CVAC_DataDir + "/" + data.file.directory.relativePath + "/" + data.file.filename);
		}

		std::vector<std::string> fileNameStrings =  expandSeq_fromFile(archiveFilePath, getName(current));
		// TODO add getting the threshold value from the detector properties but for now
		// hard code the value
		float thresHold = 0.9f;

		// Need to strip off extra zeros
		std::string directory = std::string(cvac::getCurrentWorkingDirectory().c_str());
		std::string name = getName(current);
		std::string xmlFilename = fileNameStrings[0]; // Only 1 data file in the zip

		std::string dpath;
		dpath.reserve(directory.length() + name.length() + 3);
		dpath += directory;
		dpath += std::string("/");

		dpath += ".";
		dpath += name;
		if(pSBDCV->test_loadSVM(dpath,xmlFilename))
		{			
			fInitialized = true;
		}
		else
		{
			fInitialized = false;
		}
	}

}



bool SBDICETestI::isInitialized(const ::Ice::Current& current)
{
	return fInitialized;
}

void SBDICETestI::destroy(const ::Ice::Current& current)
{
	if(pSBDCV != NULL)
		delete pSBDCV;
	pSBDCV = NULL;

	fInitialized = false;
}
std::string SBDICETestI::getName(const ::Ice::Current& current)
{
	return "SBD Test";
}
std::string SBDICETestI::getDescription(const ::Ice::Current& current)
{
	return "SBD Test - Empty Description";
}

void SBDICETestI::setVerbosity(::Ice::Int verbosity, const ::Ice::Current& current)
{

}

cvac::DetectorData SBDICETestI::createCopyOfDetectorData(const ::Ice::Current& current)
{
	// need to update (lekomin)
	cvac::DetectorData data;
	return data;
}

cvac::DetectorPropertiesPrx SBDICETestI::getDetectorProperties(const ::Ice::Current& current)
{
	// need to update (lekomin)
	return NULL;
}

cvac::ResultSetV2 SBDICETestI::processSingleVideo(cvac::DetectorPtr detector, const char* fullfilename)
{
	bool isVideoFile = false;
	std::string fullfilename_str = std::string(fullfilename);
	int _idxPeriod = fullfilename_str.rfind(".");
	std::string _extension = fullfilename_str.substr( (_idxPeriod + 1),fullfilename_str.length());

	if  (!strcmp(_extension.c_str(),"mpg")  || !strcmp(_extension.c_str(),"mpeg") || !strcmp(_extension.c_str(),"mp4")) 
	{
		isVideoFile = true;
	}

	if(isVideoFile)
	{
		std::string _ffullname = std::string(fullfilename);

		if(SBDICETestI::m_verbosity >= 2)
		{ // ToDo: Use full printv function
			std::cout << "===========================================" << std::endl;
			std::cout << _ffullname << " is processing" << std::endl;
		}

		SBDICETestI* _SBDCV = static_cast<SBDICETestI*>(detector.get());

		std::vector<long> _vFrameListOutput;
		std::string _resultFileName;
		_SBDCV->pSBDCV->test_run(_ffullname,_vFrameListOutput, true,_resultFileName, false);  
		//the third parameter: whether to export the result frames to a TXT file
		//the fifth parameter: whether to save the boundary images

<<<<<<< .mine
	cvac::ResultSetV2 _resSet;	
	cvac::Result _tResult;
	_tResult.original = new cvac::Labelable();
	_tResult.original->sub.path.filename = _ffullname;
    // Add a LabeledVideo for each frame we found
	for(size_t k=0;k<_vFrameListOutput.size();k++)
	{		
        cvac::LabeledVideo *vlabel = new cvac::LabeledVideo();
        vlabel->fromFrame.time = _vFrameListOutput[k];			
		vlabel->toFrame.time = NULL;
        vlabel->loc = NULL;		
		_tResult.foundLabels.push_back(vlabel);						
	}
    
	/*cvac::LabeledTrack* videoLabel = new cvac::LabeledTrack();	
	videoLabel->sub.path.filename = _resultFileName;	*/
	
	/*for(size_t k=0;k<_vFrameListOutput.size();k++)
	{			
		cvac::FrameLocation _frameIdx;		
		_frameIdx.frame.time = _vFrameListOutput[k];		
		videoLabel->keyframesLocations.push_back(_frameIdx);						
	}
   videoLabel->interp = cvac::DISCRETE;
  	_tResult.foundLabels.push_back(videoLabel);*/
=======
		if(SBDICETestI::m_verbosity >= 3)
		{ // ToDo: Use full printv function
			std::cout << _ffullname << " is processed" << std::endl;
		}
>>>>>>> .r388

		cvac::ResultSetV2 _resSet;	
		cvac::Result _tResult;
		_tResult.original = new cvac::Labelable();
		_tResult.original->sub.path.filename = _ffullname;

		cvac::LabeledTrack* videoLabel = new cvac::LabeledTrack();	
		videoLabel->sub.path.filename = _resultFileName;	

		for(size_t k=0;k<_vFrameListOutput.size();k++)
		{			
			cvac::FrameLocation _frameIdx;		
			_frameIdx.frame.time = _vFrameListOutput[k];		
			videoLabel->keyframesLocations.push_back(_frameIdx);						
		}
		videoLabel->interp = cvac::DISCRETE;
		_tResult.foundLabels.push_back(videoLabel);

		_resSet.results.push_back(_tResult);

		return _resSet;
	}
	else
	{ // Not a valid video file
		if(SBDICETestI::m_verbosity >= 2) 
		{ // ToDo: Use full printv function
			std::cout << "Skipping file: " << fullfilename_str << " with non-accepted format.  Accepts: 'mpg', 'mpeg', 'mp4'" << endl;
		}
		cvac::ResultSetV2 empty;
		return empty;
	}
}

void SBDICETestI::process(const ::cvac::DetectorCallbackHandlerPrx& callbackHandler,const ::cvac::RunSet& runset,const ::Ice::Current& current)
{
	cvac::DoDetectFunc func = SBDICETestI::processSingleVideo;
	cvac::processRunSet(this, callbackHandler, func, runset, m_CVAC_DataDir);
}
