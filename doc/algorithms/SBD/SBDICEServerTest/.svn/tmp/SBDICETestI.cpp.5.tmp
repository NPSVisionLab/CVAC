#include "SBDICETestI.h"
#include <iostream>
#include <vector>

#include <Ice/Communicator.h>
#include <Ice/Initialize.h>
#include <Ice/ObjectAdapter.h>
#include <CVACUtil/processRunSet.h>
#include <CVACUtil/FileUtils.h>
#include <CVACUtil/DetectorDataArchive.h>
#include <CVACUtil/ServiceMan.h>

std::string SBDICETestI::m_CVAC_DataDir = ""; // Stored on initilization of Detector
int SBDICETestI::m_verbosity = 0; // Implementation of static class variable

SBDICETestI::SBDICETestI()
: pSBDCV(NULL),fInitialized(false)
{

}

SBDICETestI::~SBDICETestI()
{
	delete pSBDCV;
	pSBDCV = NULL;
}

void SBDICETestI::initialize(::Ice::Int verbosity, const ::cvac::DetectorData& data, const ::Ice::Current& current)
{
    // Since constructor only called on service start and destroy can be called.  We need to make sure we have it
    if (pSBDCV == NULL)
        pSBDCV = new SBDCV();
	m_verbosity = (int)verbosity; // Save verbosity state within SBDICETestI
	int size = data.data.size();
  Ice::PropertiesPtr props = (current.adapter->getCommunicator()->getProperties());
  cvac::vLogger.setLocalVerbosityLevel(props->getProperty("CVAC.ServicesVerbosity"));

	// Load the CVAC property: 'CVAC.DataDir'.  Used for the svm filename path, and to correct Runset paths
	m_CVAC_DataDir = props->getProperty("CVAC.DataDir");
	if(m_CVAC_DataDir.empty()) 
	{
		cvac::localAndClientMsg(VLogger::WARN, NULL, "Unable to locate CVAC Data directory, specified: 'CVAC.DataDir = path/to/dataDir' in </CVAC_Services/config.service>\n");
	}
  cvac::localAndClientMsg(VLogger::DEBUG, NULL, "CVAC Data directory configured as: %s \n", m_CVAC_DataDir.c_str());

	if (!data.data.empty())
	{
		//////////////////////////////////////////////////////////////////////////
		// Setup: loading the SVM result
		cvac::ByteSeq byteSeq = data.data;
		Ice::InputStreamPtr input = Ice::createInputStream(current.adapter->getCommunicator(), byteSeq);
		std::vector<std::string> strSeq;
		input->read(strSeq);	 //0: directory including the file "svm_Result.xml.gz"

		//detectorData.file.directory.relativePath = std::string(argv[2]);
		//detectorData.file.filename = std::string(argv[3]);

		if(m_verbosity >= 2)
		{	
			cvac::localAndClientMsg(VLogger::DEBUG, NULL, "Initializing Shot Boundary Detection: %s/%s\n", data.file.directory.relativePath.c_str(), data.file.filename.c_str());
      cvac::localAndClientMsg(VLogger::DEBUG_1, NULL, "Directory including the file svm_Result.xml.gz: %s\n", strSeq[0].c_str());
		}

		//if(pSBDCV->test_loadSVM(strSeq[0],svmResult_xml))
		if(pSBDCV->test_loadSVM(data.file.directory.relativePath,data.file.filename))
		{			
			fInitialized = true;
		}
		else
		{
			fInitialized = false;
		}
	}
	else if (cvac::FILE == data.type && size == 0)
	{ // we have a zip filename being passed in
		// Use utils un-compression to get extracted file names
		std::string archiveFilePath; 
		if ((data.file.directory.relativePath.length() > 1 && data.file.directory.relativePath[1] == ':' )||
			data.file.directory.relativePath[0] == '/' ||
			data.file.directory.relativePath[0] == '\\')
		{  // absolute path
			archiveFilePath = data.file.directory.relativePath + "/" + data.file.filename;
		}
		else
		{ // prepend our prefix
			archiveFilePath = (m_CVAC_DataDir + "/" + data.file.directory.relativePath + "/" + data.file.filename);
		}

		std::vector<std::string> fileNameStrings =  expandSeq_fromFile(archiveFilePath, getName(current));
		// TODO add getting the threshold value from the detector properties but for now, hard code the value
		float thresHold = 0.9f;

		// Need to strip off extra zeros
		std::string directory = std::string(cvac::getCurrentWorkingDirectory().c_str());
		std::string name = getName(current);
		std::string xmlFilename = fileNameStrings[0]; // Only 1 data file in the zip

		std::string dpath;
		dpath.reserve(directory.length() + name.length() + 3);
		dpath += directory;
		dpath += std::string("/");

		dpath += ".";
		dpath += name;
		if(pSBDCV->test_loadSVM(dpath,xmlFilename))
		{			
			fInitialized = true;
		}
		else
		{
			fInitialized = false;
		}
	}

}



bool SBDICETestI::isInitialized(const ::Ice::Current& current)
{
	return fInitialized;
}

void SBDICETestI::destroy(const ::Ice::Current& current)
{
	if(pSBDCV != NULL)
		delete pSBDCV;
	pSBDCV = NULL;

	fInitialized = false;
}
std::string SBDICETestI::getName(const ::Ice::Current& current)
{
	return "SBDTest";
}
std::string SBDICETestI::getDescription(const ::Ice::Current& current)
{
	return "SBD Test - Empty Description";
}

void SBDICETestI::setVerbosity(::Ice::Int verbosity, const ::Ice::Current& current)
{

}

cvac::DetectorData SBDICETestI::createCopyOfDetectorData(const ::Ice::Current& current)
{
	// need to update (lekomin)
	cvac::DetectorData data;
	return data;
}

cvac::DetectorPropertiesPrx SBDICETestI::getDetectorProperties(const ::Ice::Current& current)
{
	// need to update (lekomin)
	return NULL;
}

cvac::ResultSetV2 SBDICETestI::processSingleVideo(cvac::DetectorPtr detector, const char* fullfilename)
{
	bool isVideoFile = false;
	std::string fullfilename_str = std::string(fullfilename);
	int _idxPeriod = fullfilename_str.rfind(".");
	std::string _extension = fullfilename_str.substr( (_idxPeriod + 1),fullfilename_str.length());

	if  (!strcmp(_extension.c_str(),"mpg")  || !strcmp(_extension.c_str(),"mpeg") || !strcmp(_extension.c_str(),"mp4")) 
	{
		isVideoFile = true;
	}

	if(isVideoFile)
	{
		std::string _ffullname = std::string(fullfilename);

		cvac::localAndClientMsg(VLogger::DEBUG, NULL, "%s is processing\n", _ffullname.c_str());

		SBDICETestI* _SBDCV = static_cast<SBDICETestI*>(detector.get());

		std::vector<long> _vFrameListOutput;
		std::string _resultFileName;
		_SBDCV->pSBDCV->test_run(_ffullname,_vFrameListOutput, true,_resultFileName, false);  
		//the third parameter: whether to export the result frames to a TXT file
		//the fifth parameter: whether to save the boundary images

      cvac::ResultSetV2 _resSet;	
      cvac::Result _tResult;
      _tResult.original = new cvac::Labelable();
      _tResult.original->sub.path.filename = _ffullname;
       // Add a LabeledVideo for each frame we found
      for(size_t k=0;k<_vFrameListOutput.size();k++)
      {		
           cvac::LabeledVideoSegment *vlabel = new cvac::LabeledVideoSegment();
           vlabel->start.time = _vFrameListOutput[k];			
           vlabel->last.time = NULL;
           vlabel->loc = NULL;		
         _tResult.foundLabels.push_back(vlabel);						
      }
    
     /*cvac::LabeledTrack* videoLabel = new cvac::LabeledTrack();	
     videoLabel->sub.path.filename = _resultFileName;	*/
	
     /*for(size_t k=0;k<_vFrameListOutput.size();k++)
     {			
        cvac::FrameLocation _frameIdx;		
        _frameIdx.frame.time = _vFrameListOutput[k];		
        videoLabel->keyframesLocations.push_back(_frameIdx);						
     }
     videoLabel->interp = cvac::DISCRETE;
     _tResult.foundLabels.push_back(videoLabel);*/

     cvac::localAndClientMsg(VLogger::DEBUG, NULL, "%s is processed.\n", _ffullname.c_str());

 		_resSet.results.push_back(_tResult);

		return _resSet;
	}
	else
	{ // Not a valid video file
    cvac::localAndClientMsg(VLogger::DEBUG, NULL, "Skipping file: %s with non-accepted format.  Accepts: 'mpg', 'mpeg', 'mp4'\n", fullfilename_str.c_str());

		cvac::ResultSetV2 empty;
		return empty;
	}
}

void SBDICETestI::process(const Ice::Identity &client,const ::cvac::RunSet& runset,const ::Ice::Current& current)
{
	cvac::DetectorCallbackHandlerPrx _callback = cvac::DetectorCallbackHandlerPrx::uncheckedCast(current.con->createProxy(client)->ice_oneway());
	cvac::DoDetectFunc func = SBDICETestI::processSingleVideo;
	cvac::processRunSet(this, _callback, func, runset, m_CVAC_DataDir);
}
