// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Data.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Data_h__
#define __Data_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace cvac
{

class PurposedList;

class Labelable;

class PurposedLabelableSeq;

class PurposedDirectory;

class Location;

class Point2D;

class BBox;

class PreciseLocation;

class PreciseBBox;

class PreciseCircle;

class Silhouette;

class LabeledFullSubstrate;

class LabeledLocation;

class LabeledVideoSegment;

class LabeledTrack;

}

}

namespace cvac
{

class PurposedList;
bool operator==(const PurposedList&, const PurposedList&);
bool operator<(const PurposedList&, const PurposedList&);

class Labelable;
bool operator==(const Labelable&, const Labelable&);
bool operator<(const Labelable&, const Labelable&);

class PurposedLabelableSeq;
bool operator==(const PurposedLabelableSeq&, const PurposedLabelableSeq&);
bool operator<(const PurposedLabelableSeq&, const PurposedLabelableSeq&);

class PurposedDirectory;
bool operator==(const PurposedDirectory&, const PurposedDirectory&);
bool operator<(const PurposedDirectory&, const PurposedDirectory&);

class Location;
bool operator==(const Location&, const Location&);
bool operator<(const Location&, const Location&);

class Point2D;
bool operator==(const Point2D&, const Point2D&);
bool operator<(const Point2D&, const Point2D&);

class BBox;
bool operator==(const BBox&, const BBox&);
bool operator<(const BBox&, const BBox&);

class PreciseLocation;
bool operator==(const PreciseLocation&, const PreciseLocation&);
bool operator<(const PreciseLocation&, const PreciseLocation&);

class PreciseBBox;
bool operator==(const PreciseBBox&, const PreciseBBox&);
bool operator<(const PreciseBBox&, const PreciseBBox&);

class PreciseCircle;
bool operator==(const PreciseCircle&, const PreciseCircle&);
bool operator<(const PreciseCircle&, const PreciseCircle&);

class Silhouette;
bool operator==(const Silhouette&, const Silhouette&);
bool operator<(const Silhouette&, const Silhouette&);

class LabeledFullSubstrate;
bool operator==(const LabeledFullSubstrate&, const LabeledFullSubstrate&);
bool operator<(const LabeledFullSubstrate&, const LabeledFullSubstrate&);

class LabeledLocation;
bool operator==(const LabeledLocation&, const LabeledLocation&);
bool operator<(const LabeledLocation&, const LabeledLocation&);

class LabeledVideoSegment;
bool operator==(const LabeledVideoSegment&, const LabeledVideoSegment&);
bool operator<(const LabeledVideoSegment&, const LabeledVideoSegment&);

class LabeledTrack;
bool operator==(const LabeledTrack&, const LabeledTrack&);
bool operator<(const LabeledTrack&, const LabeledTrack&);

}

namespace IceInternal
{

::Ice::Object* upCast(::cvac::PurposedList*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::PurposedList*);

::Ice::Object* upCast(::cvac::Labelable*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::Labelable*);

::Ice::Object* upCast(::cvac::PurposedLabelableSeq*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::PurposedLabelableSeq*);

::Ice::Object* upCast(::cvac::PurposedDirectory*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::PurposedDirectory*);

::Ice::Object* upCast(::cvac::Location*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::Location*);

::Ice::Object* upCast(::cvac::Point2D*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::Point2D*);

::Ice::Object* upCast(::cvac::BBox*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::BBox*);

::Ice::Object* upCast(::cvac::PreciseLocation*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::PreciseLocation*);

::Ice::Object* upCast(::cvac::PreciseBBox*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::PreciseBBox*);

::Ice::Object* upCast(::cvac::PreciseCircle*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::PreciseCircle*);

::Ice::Object* upCast(::cvac::Silhouette*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::Silhouette*);

::Ice::Object* upCast(::cvac::LabeledFullSubstrate*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::LabeledFullSubstrate*);

::Ice::Object* upCast(::cvac::LabeledLocation*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::LabeledLocation*);

::Ice::Object* upCast(::cvac::LabeledVideoSegment*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::LabeledVideoSegment*);

::Ice::Object* upCast(::cvac::LabeledTrack*);
::IceProxy::Ice::Object* upCast(::IceProxy::cvac::LabeledTrack*);

}

namespace cvac
{

typedef ::IceInternal::Handle< ::cvac::PurposedList> PurposedListPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::PurposedList> PurposedListPrx;

void __read(::IceInternal::BasicStream*, PurposedListPrx&);
void __patch__PurposedListPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::Labelable> LabelablePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::Labelable> LabelablePrx;

void __read(::IceInternal::BasicStream*, LabelablePrx&);
void __patch__LabelablePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::PurposedLabelableSeq> PurposedLabelableSeqPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::PurposedLabelableSeq> PurposedLabelableSeqPrx;

void __read(::IceInternal::BasicStream*, PurposedLabelableSeqPrx&);
void __patch__PurposedLabelableSeqPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::PurposedDirectory> PurposedDirectoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::PurposedDirectory> PurposedDirectoryPrx;

void __read(::IceInternal::BasicStream*, PurposedDirectoryPrx&);
void __patch__PurposedDirectoryPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::Location> LocationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::Location> LocationPrx;

void __read(::IceInternal::BasicStream*, LocationPrx&);
void __patch__LocationPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::Point2D> Point2DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::Point2D> Point2DPrx;

void __read(::IceInternal::BasicStream*, Point2DPrx&);
void __patch__Point2DPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::BBox> BBoxPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::BBox> BBoxPrx;

void __read(::IceInternal::BasicStream*, BBoxPrx&);
void __patch__BBoxPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::PreciseLocation> PreciseLocationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::PreciseLocation> PreciseLocationPrx;

void __read(::IceInternal::BasicStream*, PreciseLocationPrx&);
void __patch__PreciseLocationPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::PreciseBBox> PreciseBBoxPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::PreciseBBox> PreciseBBoxPrx;

void __read(::IceInternal::BasicStream*, PreciseBBoxPrx&);
void __patch__PreciseBBoxPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::PreciseCircle> PreciseCirclePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::PreciseCircle> PreciseCirclePrx;

void __read(::IceInternal::BasicStream*, PreciseCirclePrx&);
void __patch__PreciseCirclePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::Silhouette> SilhouettePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::Silhouette> SilhouettePrx;

void __read(::IceInternal::BasicStream*, SilhouettePrx&);
void __patch__SilhouettePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::LabeledFullSubstrate> LabeledFullSubstratePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::LabeledFullSubstrate> LabeledFullSubstratePrx;

void __read(::IceInternal::BasicStream*, LabeledFullSubstratePrx&);
void __patch__LabeledFullSubstratePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::LabeledLocation> LabeledLocationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::LabeledLocation> LabeledLocationPrx;

void __read(::IceInternal::BasicStream*, LabeledLocationPrx&);
void __patch__LabeledLocationPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::LabeledVideoSegment> LabeledVideoSegmentPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::LabeledVideoSegment> LabeledVideoSegmentPrx;

void __read(::IceInternal::BasicStream*, LabeledVideoSegmentPrx&);
void __patch__LabeledVideoSegmentPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::cvac::LabeledTrack> LabeledTrackPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::cvac::LabeledTrack> LabeledTrackPrx;

void __read(::IceInternal::BasicStream*, LabeledTrackPrx&);
void __patch__LabeledTrackPtr(void*, ::Ice::ObjectPtr&);

}

namespace cvac
{

enum PurposeType
{
    UNLABELED,
    POSITIVE,
    NEGATIVE,
    MULTICLASS,
    ANY
};

void __write(::IceInternal::BasicStream*, PurposeType);
void __read(::IceInternal::BasicStream*, PurposeType&);

struct Purpose
{
    Purpose();
    Purpose(::cvac::PurposeType, ::Ice::Int);

    ::cvac::PurposeType ptype;
    ::Ice::Int classID;

    bool operator==(const Purpose& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(ptype != __rhs.ptype)
        {
            return false;
        }
        if(classID != __rhs.classID)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Purpose& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(ptype < __rhs.ptype)
        {
            return true;
        }
        else if(__rhs.ptype < ptype)
        {
            return false;
        }
        if(classID < __rhs.classID)
        {
            return true;
        }
        else if(__rhs.classID < classID)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Purpose& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Purpose& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Purpose& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Purpose& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::cvac::LabelablePtr> LabelableList;
void __writeLabelableList(::IceInternal::BasicStream*, const ::cvac::LabelablePtr*, const ::cvac::LabelablePtr*);
void __readLabelableList(::IceInternal::BasicStream*, LabelableList&);

struct DirectoryPath
{
    ::std::string relativePath;

    bool operator==(const DirectoryPath& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(relativePath != __rhs.relativePath)
        {
            return false;
        }
        return true;
    }

    bool operator<(const DirectoryPath& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(relativePath < __rhs.relativePath)
        {
            return true;
        }
        else if(__rhs.relativePath < relativePath)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const DirectoryPath& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const DirectoryPath& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const DirectoryPath& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const DirectoryPath& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::std::string> StringList;

typedef ::std::vector< ::cvac::PurposedListPtr> PurposedListSequence;
void __writePurposedListSequence(::IceInternal::BasicStream*, const ::cvac::PurposedListPtr*, const ::cvac::PurposedListPtr*);
void __readPurposedListSequence(::IceInternal::BasicStream*, PurposedListSequence&);

struct RunSet
{
    ::cvac::PurposedListSequence purposedLists;

    bool operator==(const RunSet& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(purposedLists != __rhs.purposedLists)
        {
            return false;
        }
        return true;
    }

    bool operator<(const RunSet& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(purposedLists < __rhs.purposedLists)
        {
            return true;
        }
        else if(__rhs.purposedLists < purposedLists)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const RunSet& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const RunSet& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const RunSet& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const RunSet& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct FilePath
{
    ::cvac::DirectoryPath directory;
    ::std::string filename;

    bool operator==(const FilePath& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(directory != __rhs.directory)
        {
            return false;
        }
        if(filename != __rhs.filename)
        {
            return false;
        }
        return true;
    }

    bool operator<(const FilePath& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(directory < __rhs.directory)
        {
            return true;
        }
        else if(__rhs.directory < directory)
        {
            return false;
        }
        if(filename < __rhs.filename)
        {
            return true;
        }
        else if(__rhs.filename < filename)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const FilePath& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const FilePath& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const FilePath& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const FilePath& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct Substrate
{
    Substrate();
    Substrate(bool, bool, const ::cvac::FilePath&, ::Ice::Int, ::Ice::Int);

    bool isImage;
    bool isVideo;
    ::cvac::FilePath path;
    ::Ice::Int width;
    ::Ice::Int height;

    bool operator==(const Substrate& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(isImage != __rhs.isImage)
        {
            return false;
        }
        if(isVideo != __rhs.isVideo)
        {
            return false;
        }
        if(path != __rhs.path)
        {
            return false;
        }
        if(width != __rhs.width)
        {
            return false;
        }
        if(height != __rhs.height)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Substrate& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(isImage < __rhs.isImage)
        {
            return true;
        }
        else if(__rhs.isImage < isImage)
        {
            return false;
        }
        if(isVideo < __rhs.isVideo)
        {
            return true;
        }
        else if(__rhs.isVideo < isVideo)
        {
            return false;
        }
        if(path < __rhs.path)
        {
            return true;
        }
        else if(__rhs.path < path)
        {
            return false;
        }
        if(width < __rhs.width)
        {
            return true;
        }
        else if(__rhs.width < width)
        {
            return false;
        }
        if(height < __rhs.height)
        {
            return true;
        }
        else if(__rhs.height < height)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Substrate& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Substrate& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Substrate& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Substrate& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::map< ::std::string, ::std::string> LabelProperties;
void __writeLabelProperties(::IceInternal::BasicStream*, const LabelProperties&);
void __readLabelProperties(::IceInternal::BasicStream*, LabelProperties&);

struct Semantics
{
    ::std::string url;

    bool operator==(const Semantics& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(url != __rhs.url)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Semantics& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(url < __rhs.url)
        {
            return true;
        }
        else if(__rhs.url < url)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Semantics& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Semantics& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Semantics& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Semantics& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct Label
{
    bool hasLabel;
    ::std::string name;
    ::cvac::LabelProperties properties;
    ::cvac::Semantics semantix;

    bool operator==(const Label& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(hasLabel != __rhs.hasLabel)
        {
            return false;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(properties != __rhs.properties)
        {
            return false;
        }
        if(semantix != __rhs.semantix)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Label& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(hasLabel < __rhs.hasLabel)
        {
            return true;
        }
        else if(__rhs.hasLabel < hasLabel)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(properties < __rhs.properties)
        {
            return true;
        }
        else if(__rhs.properties < properties)
        {
            return false;
        }
        if(semantix < __rhs.semantix)
        {
            return true;
        }
        else if(__rhs.semantix < semantix)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Label& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Label& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Label& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Label& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct Size
{
    ::Ice::Int width;
    ::Ice::Int height;

    bool operator==(const Size& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(width != __rhs.width)
        {
            return false;
        }
        if(height != __rhs.height)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Size& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(width < __rhs.width)
        {
            return true;
        }
        else if(__rhs.width < width)
        {
            return false;
        }
        if(height < __rhs.height)
        {
            return true;
        }
        else if(__rhs.height < height)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Size& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Size& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Size& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Size& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::cvac::Point2DPtr> Point2DList;
void __writePoint2DList(::IceInternal::BasicStream*, const ::cvac::Point2DPtr*, const ::cvac::Point2DPtr*);
void __readPoint2DList(::IceInternal::BasicStream*, Point2DList&);

struct VideoSeekTime
{
    ::Ice::Long time;
    ::Ice::Long framecnt;

    bool operator==(const VideoSeekTime& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(time != __rhs.time)
        {
            return false;
        }
        if(framecnt != __rhs.framecnt)
        {
            return false;
        }
        return true;
    }

    bool operator<(const VideoSeekTime& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(time < __rhs.time)
        {
            return true;
        }
        else if(__rhs.time < time)
        {
            return false;
        }
        if(framecnt < __rhs.framecnt)
        {
            return true;
        }
        else if(__rhs.framecnt < framecnt)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const VideoSeekTime& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const VideoSeekTime& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const VideoSeekTime& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const VideoSeekTime& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct FrameLocation
{
    ::cvac::VideoSeekTime frame;
    ::cvac::LocationPtr loc;

    bool operator==(const FrameLocation& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(frame != __rhs.frame)
        {
            return false;
        }
        if(loc != __rhs.loc)
        {
            return false;
        }
        return true;
    }

    bool operator<(const FrameLocation& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(frame < __rhs.frame)
        {
            return true;
        }
        else if(__rhs.frame < frame)
        {
            return false;
        }
        if(loc < __rhs.loc)
        {
            return true;
        }
        else if(__rhs.loc < loc)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const FrameLocation& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const FrameLocation& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const FrameLocation& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const FrameLocation& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::cvac::FrameLocation> FrameLocationList;
void __writeFrameLocationList(::IceInternal::BasicStream*, const ::cvac::FrameLocation*, const ::cvac::FrameLocation*);
void __readFrameLocationList(::IceInternal::BasicStream*, FrameLocationList&);

enum Interpolation
{
    DISCRETE,
    LINEAR,
    POLYNOMIAL
};

void __write(::IceInternal::BasicStream*, Interpolation);
void __read(::IceInternal::BasicStream*, Interpolation&);

struct Result
{
    ::cvac::LabelablePtr original;
    ::cvac::LabelableList foundLabels;

    bool operator==(const Result& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(original != __rhs.original)
        {
            return false;
        }
        if(foundLabels != __rhs.foundLabels)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Result& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(original < __rhs.original)
        {
            return true;
        }
        else if(__rhs.original < original)
        {
            return false;
        }
        if(foundLabels < __rhs.foundLabels)
        {
            return true;
        }
        else if(__rhs.foundLabels < foundLabels)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Result& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Result& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Result& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Result& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::cvac::Result> ResultList;
void __writeResultList(::IceInternal::BasicStream*, const ::cvac::Result*, const ::cvac::Result*);
void __readResultList(::IceInternal::BasicStream*, ResultList&);

struct ResultSetV2
{
    ::cvac::ResultList results;

    bool operator==(const ResultSetV2& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(results != __rhs.results)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ResultSetV2& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(results < __rhs.results)
        {
            return true;
        }
        else if(__rhs.results < results)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ResultSetV2& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ResultSetV2& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ResultSetV2& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ResultSetV2& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Ice::Byte> ByteSeq;

}

namespace cvac
{

}

namespace IceProxy
{

namespace cvac
{

class PurposedList : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<PurposedList> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedList> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedList*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<PurposedList*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PurposedLabelableSeq : virtual public ::IceProxy::cvac::PurposedList
{
public:
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedLabelableSeq> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedLabelableSeq*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<PurposedLabelableSeq*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PurposedDirectory : virtual public ::IceProxy::cvac::PurposedList
{
public:
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PurposedDirectory> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PurposedDirectory*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<PurposedDirectory*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Labelable : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Labelable> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Labelable> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Labelable*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Labelable*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Location : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<Location> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Location> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Location*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Location*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Point2D : virtual public ::IceProxy::cvac::Location
{
public:
    
    ::IceInternal::ProxyHandle<Point2D> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Point2D> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Point2D*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Point2D*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BBox : virtual public ::IceProxy::cvac::Location
{
public:
    
    ::IceInternal::ProxyHandle<BBox> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<BBox> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<BBox*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<BBox*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PreciseLocation : virtual public ::IceProxy::cvac::Location
{
public:
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseLocation> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseLocation*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<PreciseLocation*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PreciseBBox : virtual public ::IceProxy::cvac::PreciseLocation
{
public:
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseBBox> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseBBox*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<PreciseBBox*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PreciseCircle : virtual public ::IceProxy::cvac::PreciseLocation
{
public:
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PreciseCircle> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PreciseCircle*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<PreciseCircle*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Silhouette : virtual public ::IceProxy::cvac::Location
{
public:
    
    ::IceInternal::ProxyHandle<Silhouette> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Silhouette> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Silhouette*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Silhouette*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class LabeledFullSubstrate : virtual public ::IceProxy::cvac::Labelable
{
public:
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledFullSubstrate> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledFullSubstrate*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<LabeledFullSubstrate*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class LabeledLocation : virtual public ::IceProxy::cvac::Labelable
{
public:
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledLocation> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledLocation*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<LabeledLocation*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class LabeledVideoSegment : virtual public ::IceProxy::cvac::Labelable
{
public:
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledVideoSegment> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledVideoSegment*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<LabeledVideoSegment*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class LabeledTrack : virtual public ::IceProxy::cvac::Labelable
{
public:
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LabeledTrack> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LabeledTrack*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<LabeledTrack*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace cvac
{

class PurposedList : virtual public ::IceDelegate::Ice::Object
{
public:
};

class PurposedLabelableSeq : virtual public ::IceDelegate::cvac::PurposedList
{
public:
};

class PurposedDirectory : virtual public ::IceDelegate::cvac::PurposedList
{
public:
};

class Labelable : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Location : virtual public ::IceDelegate::Ice::Object
{
public:
};

class Point2D : virtual public ::IceDelegate::cvac::Location
{
public:
};

class BBox : virtual public ::IceDelegate::cvac::Location
{
public:
};

class PreciseLocation : virtual public ::IceDelegate::cvac::Location
{
public:
};

class PreciseBBox : virtual public ::IceDelegate::cvac::PreciseLocation
{
public:
};

class PreciseCircle : virtual public ::IceDelegate::cvac::PreciseLocation
{
public:
};

class Silhouette : virtual public ::IceDelegate::cvac::Location
{
public:
};

class LabeledFullSubstrate : virtual public ::IceDelegate::cvac::Labelable
{
public:
};

class LabeledLocation : virtual public ::IceDelegate::cvac::Labelable
{
public:
};

class LabeledVideoSegment : virtual public ::IceDelegate::cvac::Labelable
{
public:
};

class LabeledTrack : virtual public ::IceDelegate::cvac::Labelable
{
public:
};

}

}

namespace IceDelegateM
{

namespace cvac
{

class PurposedList : virtual public ::IceDelegate::cvac::PurposedList,
                     virtual public ::IceDelegateM::Ice::Object
{
public:
};

class PurposedLabelableSeq : virtual public ::IceDelegate::cvac::PurposedLabelableSeq,
                             virtual public ::IceDelegateM::cvac::PurposedList
{
public:
};

class PurposedDirectory : virtual public ::IceDelegate::cvac::PurposedDirectory,
                          virtual public ::IceDelegateM::cvac::PurposedList
{
public:
};

class Labelable : virtual public ::IceDelegate::cvac::Labelable,
                  virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Location : virtual public ::IceDelegate::cvac::Location,
                 virtual public ::IceDelegateM::Ice::Object
{
public:
};

class Point2D : virtual public ::IceDelegate::cvac::Point2D,
                virtual public ::IceDelegateM::cvac::Location
{
public:
};

class BBox : virtual public ::IceDelegate::cvac::BBox,
             virtual public ::IceDelegateM::cvac::Location
{
public:
};

class PreciseLocation : virtual public ::IceDelegate::cvac::PreciseLocation,
                        virtual public ::IceDelegateM::cvac::Location
{
public:
};

class PreciseBBox : virtual public ::IceDelegate::cvac::PreciseBBox,
                    virtual public ::IceDelegateM::cvac::PreciseLocation
{
public:
};

class PreciseCircle : virtual public ::IceDelegate::cvac::PreciseCircle,
                      virtual public ::IceDelegateM::cvac::PreciseLocation
{
public:
};

class Silhouette : virtual public ::IceDelegate::cvac::Silhouette,
                   virtual public ::IceDelegateM::cvac::Location
{
public:
};

class LabeledFullSubstrate : virtual public ::IceDelegate::cvac::LabeledFullSubstrate,
                             virtual public ::IceDelegateM::cvac::Labelable
{
public:
};

class LabeledLocation : virtual public ::IceDelegate::cvac::LabeledLocation,
                        virtual public ::IceDelegateM::cvac::Labelable
{
public:
};

class LabeledVideoSegment : virtual public ::IceDelegate::cvac::LabeledVideoSegment,
                            virtual public ::IceDelegateM::cvac::Labelable
{
public:
};

class LabeledTrack : virtual public ::IceDelegate::cvac::LabeledTrack,
                     virtual public ::IceDelegateM::cvac::Labelable
{
public:
};

}

}

namespace IceDelegateD
{

namespace cvac
{

class PurposedList : virtual public ::IceDelegate::cvac::PurposedList,
                     virtual public ::IceDelegateD::Ice::Object
{
public:
};

class PurposedLabelableSeq : virtual public ::IceDelegate::cvac::PurposedLabelableSeq,
                             virtual public ::IceDelegateD::cvac::PurposedList
{
public:
};

class PurposedDirectory : virtual public ::IceDelegate::cvac::PurposedDirectory,
                          virtual public ::IceDelegateD::cvac::PurposedList
{
public:
};

class Labelable : virtual public ::IceDelegate::cvac::Labelable,
                  virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Location : virtual public ::IceDelegate::cvac::Location,
                 virtual public ::IceDelegateD::Ice::Object
{
public:
};

class Point2D : virtual public ::IceDelegate::cvac::Point2D,
                virtual public ::IceDelegateD::cvac::Location
{
public:
};

class BBox : virtual public ::IceDelegate::cvac::BBox,
             virtual public ::IceDelegateD::cvac::Location
{
public:
};

class PreciseLocation : virtual public ::IceDelegate::cvac::PreciseLocation,
                        virtual public ::IceDelegateD::cvac::Location
{
public:
};

class PreciseBBox : virtual public ::IceDelegate::cvac::PreciseBBox,
                    virtual public ::IceDelegateD::cvac::PreciseLocation
{
public:
};

class PreciseCircle : virtual public ::IceDelegate::cvac::PreciseCircle,
                      virtual public ::IceDelegateD::cvac::PreciseLocation
{
public:
};

class Silhouette : virtual public ::IceDelegate::cvac::Silhouette,
                   virtual public ::IceDelegateD::cvac::Location
{
public:
};

class LabeledFullSubstrate : virtual public ::IceDelegate::cvac::LabeledFullSubstrate,
                             virtual public ::IceDelegateD::cvac::Labelable
{
public:
};

class LabeledLocation : virtual public ::IceDelegate::cvac::LabeledLocation,
                        virtual public ::IceDelegateD::cvac::Labelable
{
public:
};

class LabeledVideoSegment : virtual public ::IceDelegate::cvac::LabeledVideoSegment,
                            virtual public ::IceDelegateD::cvac::Labelable
{
public:
};

class LabeledTrack : virtual public ::IceDelegate::cvac::LabeledTrack,
                     virtual public ::IceDelegateD::cvac::Labelable
{
public:
};

}

}

namespace cvac
{

class PurposedList : virtual public ::Ice::Object
{
public:

    typedef PurposedListPrx ProxyType;
    typedef PurposedListPtr PointerType;
    
    PurposedList() {}
    explicit PurposedList(const ::cvac::Purpose&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~PurposedList() {}

    friend class PurposedList__staticInit;

public:

    ::cvac::Purpose pur;
};

class PurposedList__staticInit
{
public:

    ::cvac::PurposedList _init;
};

static PurposedList__staticInit _PurposedList_init;

inline bool operator==(const PurposedList& l, const PurposedList& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PurposedList& l, const PurposedList& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PurposedLabelableSeq : public ::cvac::PurposedList, private IceInternal::GCShared
{
public:

    typedef PurposedLabelableSeqPrx ProxyType;
    typedef PurposedLabelableSeqPtr PointerType;
    
    PurposedLabelableSeq() {}
    PurposedLabelableSeq(const ::cvac::Purpose&, const ::cvac::LabelableList&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~PurposedLabelableSeq() {}

public:

    ::cvac::LabelableList labeledArtifacts;
};

inline bool operator==(const PurposedLabelableSeq& l, const PurposedLabelableSeq& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PurposedLabelableSeq& l, const PurposedLabelableSeq& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PurposedDirectory : public ::cvac::PurposedList
{
public:

    typedef PurposedDirectoryPrx ProxyType;
    typedef PurposedDirectoryPtr PointerType;
    
    PurposedDirectory() {}
    PurposedDirectory(const ::cvac::Purpose&, const ::cvac::DirectoryPath&, const ::cvac::StringList&, bool);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~PurposedDirectory() {}

public:

    ::cvac::DirectoryPath directory;

    ::cvac::StringList fileSuffixes;

    bool recursive;
};

inline bool operator==(const PurposedDirectory& l, const PurposedDirectory& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PurposedDirectory& l, const PurposedDirectory& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Labelable : virtual public ::Ice::Object
{
public:

    typedef LabelablePrx ProxyType;
    typedef LabelablePtr PointerType;
    
    Labelable() {}
    Labelable(::Ice::Float, const ::cvac::Label&, const ::cvac::Substrate&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~Labelable() {}

public:

    ::Ice::Float confidence;

    ::cvac::Label lab;

    ::cvac::Substrate sub;
};

inline bool operator==(const Labelable& l, const Labelable& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Labelable& l, const Labelable& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Location : virtual public ::Ice::Object
{
public:

    typedef LocationPrx ProxyType;
    typedef LocationPtr PointerType;
    
    Location() {}
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~Location() {}
};

inline bool operator==(const Location& l, const Location& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Location& l, const Location& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Point2D : public ::cvac::Location
{
public:

    typedef Point2DPrx ProxyType;
    typedef Point2DPtr PointerType;
    
    Point2D() {}
    Point2D(::Ice::Int, ::Ice::Int);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~Point2D() {}

public:

    ::Ice::Int x;

    ::Ice::Int y;
};

inline bool operator==(const Point2D& l, const Point2D& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Point2D& l, const Point2D& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class BBox : public ::cvac::Location
{
public:

    typedef BBoxPrx ProxyType;
    typedef BBoxPtr PointerType;
    
    BBox() {}
    BBox(::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~BBox() {}

public:

    ::Ice::Int x;

    ::Ice::Int y;

    ::Ice::Int width;

    ::Ice::Int height;
};

inline bool operator==(const BBox& l, const BBox& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BBox& l, const BBox& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PreciseLocation : public ::cvac::Location
{
public:

    typedef PreciseLocationPrx ProxyType;
    typedef PreciseLocationPtr PointerType;
    
    PreciseLocation() {}
    PreciseLocation(::Ice::Float, ::Ice::Float);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~PreciseLocation() {}

public:

    ::Ice::Float centerX;

    ::Ice::Float centerY;
};

inline bool operator==(const PreciseLocation& l, const PreciseLocation& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PreciseLocation& l, const PreciseLocation& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PreciseBBox : public ::cvac::PreciseLocation
{
public:

    typedef PreciseBBoxPrx ProxyType;
    typedef PreciseBBoxPtr PointerType;
    
    PreciseBBox() {}
    PreciseBBox(::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~PreciseBBox() {}

public:

    ::Ice::Float width;

    ::Ice::Float height;
};

inline bool operator==(const PreciseBBox& l, const PreciseBBox& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PreciseBBox& l, const PreciseBBox& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PreciseCircle : public ::cvac::PreciseLocation
{
public:

    typedef PreciseCirclePrx ProxyType;
    typedef PreciseCirclePtr PointerType;
    
    PreciseCircle() {}
    PreciseCircle(::Ice::Float, ::Ice::Float, ::Ice::Float);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~PreciseCircle() {}

public:

    ::Ice::Float radius;
};

inline bool operator==(const PreciseCircle& l, const PreciseCircle& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PreciseCircle& l, const PreciseCircle& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Silhouette : public ::cvac::Location, private IceInternal::GCShared
{
public:

    typedef SilhouettePrx ProxyType;
    typedef SilhouettePtr PointerType;
    
    Silhouette() {}
    explicit Silhouette(const ::cvac::Point2DList&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~Silhouette() {}

public:

    ::cvac::Point2DList points;
};

inline bool operator==(const Silhouette& l, const Silhouette& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Silhouette& l, const Silhouette& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class LabeledFullSubstrate : public ::cvac::Labelable
{
public:

    typedef LabeledFullSubstratePrx ProxyType;
    typedef LabeledFullSubstratePtr PointerType;
    
    LabeledFullSubstrate() {}
    LabeledFullSubstrate(::Ice::Float, const ::cvac::Label&, const ::cvac::Substrate&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~LabeledFullSubstrate() {}
};

inline bool operator==(const LabeledFullSubstrate& l, const LabeledFullSubstrate& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LabeledFullSubstrate& l, const LabeledFullSubstrate& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class LabeledLocation : public ::cvac::Labelable, private IceInternal::GCShared
{
public:

    typedef LabeledLocationPrx ProxyType;
    typedef LabeledLocationPtr PointerType;
    
    LabeledLocation() {}
    LabeledLocation(::Ice::Float, const ::cvac::Label&, const ::cvac::Substrate&, const ::cvac::LocationPtr&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~LabeledLocation() {}

public:

    ::cvac::LocationPtr loc;
};

inline bool operator==(const LabeledLocation& l, const LabeledLocation& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LabeledLocation& l, const LabeledLocation& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class LabeledVideoSegment : public ::cvac::Labelable, private IceInternal::GCShared
{
public:

    typedef LabeledVideoSegmentPrx ProxyType;
    typedef LabeledVideoSegmentPtr PointerType;
    
    LabeledVideoSegment() {}
    LabeledVideoSegment(::Ice::Float, const ::cvac::Label&, const ::cvac::Substrate&, const ::cvac::VideoSeekTime&, const ::cvac::VideoSeekTime&, const ::cvac::VideoSeekTime&, const ::cvac::VideoSeekTime&, const ::cvac::LocationPtr&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~LabeledVideoSegment() {}

public:

    ::cvac::VideoSeekTime start;

    ::cvac::VideoSeekTime last;

    ::cvac::VideoSeekTime startAfterTx;

    ::cvac::VideoSeekTime lastBeforeTx;

    ::cvac::LocationPtr loc;
};

inline bool operator==(const LabeledVideoSegment& l, const LabeledVideoSegment& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LabeledVideoSegment& l, const LabeledVideoSegment& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class LabeledTrack : public ::cvac::Labelable, private IceInternal::GCShared
{
public:

    typedef LabeledTrackPrx ProxyType;
    typedef LabeledTrackPtr PointerType;
    
    LabeledTrack() {}
    LabeledTrack(::Ice::Float, const ::cvac::Label&, const ::cvac::Substrate&, const ::cvac::FrameLocationList&, ::cvac::Interpolation);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:

    virtual ~LabeledTrack() {}

public:

    ::cvac::FrameLocationList keyframesLocations;

    ::cvac::Interpolation interp;
};

inline bool operator==(const LabeledTrack& l, const LabeledTrack& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LabeledTrack& l, const LabeledTrack& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace cvac
{

}

#endif
