// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Data.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Data.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

::Ice::Object* IceInternal::upCast(::cvac::PurposedList* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::PurposedList* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::PurposedLabelableSeq* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::PurposedLabelableSeq* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::PurposedDirectory* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::PurposedDirectory* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::Labelable* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::Labelable* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::Location* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::Location* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::Point2D* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::Point2D* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::BBox* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::BBox* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::PreciseLocation* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::PreciseLocation* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::PreciseBBox* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::PreciseBBox* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::PreciseCircle* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::PreciseCircle* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::Silhouette* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::Silhouette* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::LabeledFullSubstrate* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::LabeledFullSubstrate* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::LabeledLocation* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::LabeledLocation* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::LabeledVideoSegment* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::LabeledVideoSegment* p) { return p; }

::Ice::Object* IceInternal::upCast(::cvac::LabeledTrack* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::cvac::LabeledTrack* p) { return p; }

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::PurposedListPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::PurposedList;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::PurposedLabelableSeqPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::PurposedLabelableSeq;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::PurposedDirectoryPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::PurposedDirectory;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::LabelablePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::Labelable;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::LocationPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::Location;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::Point2DPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::Point2D;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::BBoxPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::BBox;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::PreciseLocationPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::PreciseLocation;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::PreciseBBoxPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::PreciseBBox;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::PreciseCirclePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::PreciseCircle;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::SilhouettePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::Silhouette;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::LabeledFullSubstratePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::LabeledFullSubstrate;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::LabeledLocationPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::LabeledLocation;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::LabeledVideoSegmentPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::LabeledVideoSegment;
        v->__copyFrom(proxy);
    }
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::LabeledTrackPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::cvac::LabeledTrack;
        v->__copyFrom(proxy);
    }
}

void
cvac::__write(::IceInternal::BasicStream* __os, ::cvac::PurposeType v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 5);
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::PurposeType& v)
{
    ::Ice::Byte val;
    __is->read(val, 5);
    v = static_cast< ::cvac::PurposeType>(val);
}

cvac::Purpose::Purpose() :
    ptype(UNLABELED),
    classID(0)
{
}

cvac::Purpose::Purpose(::cvac::PurposeType __ice_ptype, ::Ice::Int __ice_classID) :
    ptype(__ice_ptype),
    classID(__ice_classID)
{
}

void
cvac::Purpose::__write(::IceInternal::BasicStream* __os) const
{
    ::cvac::__write(__os, ptype);
    __os->write(classID);
}

void
cvac::Purpose::__read(::IceInternal::BasicStream* __is)
{
    ::cvac::__read(__is, ptype);
    __is->read(classID);
}

void
cvac::__writeLabelableList(::IceInternal::BasicStream* __os, const ::cvac::LabelablePtr* begin, const ::cvac::LabelablePtr* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(begin[i].get())));
    }
}

void
cvac::__readLabelableList(::IceInternal::BasicStream* __is, ::cvac::LabelableList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(4, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __is->read(::cvac::__patch__LabelablePtr, &v[i]);
    }
}

void
cvac::DirectoryPath::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(relativePath);
}

void
cvac::DirectoryPath::__read(::IceInternal::BasicStream* __is)
{
    __is->read(relativePath);
}

void
cvac::__writePurposedListSequence(::IceInternal::BasicStream* __os, const ::cvac::PurposedListPtr* begin, const ::cvac::PurposedListPtr* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(begin[i].get())));
    }
}

void
cvac::__readPurposedListSequence(::IceInternal::BasicStream* __is, ::cvac::PurposedListSequence& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(4, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __is->read(::cvac::__patch__PurposedListPtr, &v[i]);
    }
}

void
cvac::RunSet::__write(::IceInternal::BasicStream* __os) const
{
    if(purposedLists.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::cvac::__writePurposedListSequence(__os, &purposedLists[0], &purposedLists[0] + purposedLists.size());
    }
}

void
cvac::RunSet::__read(::IceInternal::BasicStream* __is)
{
    ::cvac::__readPurposedListSequence(__is, purposedLists);
}

void
cvac::FilePath::__write(::IceInternal::BasicStream* __os) const
{
    directory.__write(__os);
    __os->write(filename);
}

void
cvac::FilePath::__read(::IceInternal::BasicStream* __is)
{
    directory.__read(__is);
    __is->read(filename);
}

cvac::Substrate::Substrate() :
    isImage(true),
    isVideo(false),
    width(0),
    height(0)
{
}

cvac::Substrate::Substrate(bool __ice_isImage, bool __ice_isVideo, const ::cvac::FilePath& __ice_path, ::Ice::Int __ice_width, ::Ice::Int __ice_height) :
    isImage(__ice_isImage),
    isVideo(__ice_isVideo),
    path(__ice_path),
    width(__ice_width),
    height(__ice_height)
{
}

void
cvac::Substrate::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(isImage);
    __os->write(isVideo);
    path.__write(__os);
    __os->write(width);
    __os->write(height);
}

void
cvac::Substrate::__read(::IceInternal::BasicStream* __is)
{
    __is->read(isImage);
    __is->read(isVideo);
    path.__read(__is);
    __is->read(width);
    __is->read(height);
}

void
cvac::__writeLabelProperties(::IceInternal::BasicStream* __os, const ::cvac::LabelProperties& v)
{
    __os->writeSize(::Ice::Int(v.size()));
    ::cvac::LabelProperties::const_iterator p;
    for(p = v.begin(); p != v.end(); ++p)
    {
        __os->write(p->first);
        __os->write(p->second);
    }
}

void
cvac::__readLabelProperties(::IceInternal::BasicStream* __is, ::cvac::LabelProperties& v)
{
    ::Ice::Int sz;
    __is->readSize(sz);
    while(sz--)
    {
        ::std::pair<const  ::std::string, ::std::string> pair;
        __is->read(const_cast< ::std::string&>(pair.first));
        ::cvac::LabelProperties::iterator __i = v.insert(v.end(), pair);
        __is->read(__i->second);
    }
}

void
cvac::Semantics::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(url);
}

void
cvac::Semantics::__read(::IceInternal::BasicStream* __is)
{
    __is->read(url);
}

void
cvac::Label::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(hasLabel);
    __os->write(name);
    ::cvac::__writeLabelProperties(__os, properties);
    semantix.__write(__os);
}

void
cvac::Label::__read(::IceInternal::BasicStream* __is)
{
    __is->read(hasLabel);
    __is->read(name);
    ::cvac::__readLabelProperties(__is, properties);
    semantix.__read(__is);
}

void
cvac::Size::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(width);
    __os->write(height);
}

void
cvac::Size::__read(::IceInternal::BasicStream* __is)
{
    __is->read(width);
    __is->read(height);
}

void
cvac::__writePoint2DList(::IceInternal::BasicStream* __os, const ::cvac::Point2DPtr* begin, const ::cvac::Point2DPtr* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(begin[i].get())));
    }
}

void
cvac::__readPoint2DList(::IceInternal::BasicStream* __is, ::cvac::Point2DList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(4, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __is->read(::cvac::__patch__Point2DPtr, &v[i]);
    }
}

void
cvac::VideoSeekTime::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(time);
    __os->write(framecnt);
}

void
cvac::VideoSeekTime::__read(::IceInternal::BasicStream* __is)
{
    __is->read(time);
    __is->read(framecnt);
}

void
cvac::FrameLocation::__write(::IceInternal::BasicStream* __os) const
{
    frame.__write(__os);
    __os->write(::Ice::ObjectPtr(::IceInternal::upCast(loc.get())));
}

void
cvac::FrameLocation::__read(::IceInternal::BasicStream* __is)
{
    frame.__read(__is);
    __is->read(::cvac::__patch__LocationPtr, &loc);
}

void
cvac::__writeFrameLocationList(::IceInternal::BasicStream* __os, const ::cvac::FrameLocation* begin, const ::cvac::FrameLocation* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
cvac::__readFrameLocationList(::IceInternal::BasicStream* __is, ::cvac::FrameLocationList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(20, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
cvac::__write(::IceInternal::BasicStream* __os, ::cvac::Interpolation v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 3);
}

void
cvac::__read(::IceInternal::BasicStream* __is, ::cvac::Interpolation& v)
{
    ::Ice::Byte val;
    __is->read(val, 3);
    v = static_cast< ::cvac::Interpolation>(val);
}

void
cvac::Result::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::Ice::ObjectPtr(::IceInternal::upCast(original.get())));
    if(foundLabels.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::cvac::__writeLabelableList(__os, &foundLabels[0], &foundLabels[0] + foundLabels.size());
    }
}

void
cvac::Result::__read(::IceInternal::BasicStream* __is)
{
    __is->read(::cvac::__patch__LabelablePtr, &original);
    ::cvac::__readLabelableList(__is, foundLabels);
}

void
cvac::__writeResultList(::IceInternal::BasicStream* __os, const ::cvac::Result* begin, const ::cvac::Result* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
cvac::__readResultList(::IceInternal::BasicStream* __is, ::cvac::ResultList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(5, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
cvac::ResultSetV2::__write(::IceInternal::BasicStream* __os) const
{
    if(results.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::cvac::__writeResultList(__os, &results[0], &results[0] + results.size());
    }
}

void
cvac::ResultSetV2::__read(::IceInternal::BasicStream* __is)
{
    ::cvac::__readResultList(__is, results);
}

const ::std::string&
IceProxy::cvac::PurposedList::ice_staticId()
{
    return ::cvac::PurposedList::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::PurposedList::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::PurposedList);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::PurposedList::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::PurposedList);
}

::IceProxy::Ice::Object*
IceProxy::cvac::PurposedList::__newInstance() const
{
    return new PurposedList;
}

const ::std::string&
IceProxy::cvac::PurposedLabelableSeq::ice_staticId()
{
    return ::cvac::PurposedLabelableSeq::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::PurposedLabelableSeq::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::PurposedLabelableSeq);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::PurposedLabelableSeq::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::PurposedLabelableSeq);
}

::IceProxy::Ice::Object*
IceProxy::cvac::PurposedLabelableSeq::__newInstance() const
{
    return new PurposedLabelableSeq;
}

const ::std::string&
IceProxy::cvac::PurposedDirectory::ice_staticId()
{
    return ::cvac::PurposedDirectory::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::PurposedDirectory::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::PurposedDirectory);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::PurposedDirectory::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::PurposedDirectory);
}

::IceProxy::Ice::Object*
IceProxy::cvac::PurposedDirectory::__newInstance() const
{
    return new PurposedDirectory;
}

const ::std::string&
IceProxy::cvac::Labelable::ice_staticId()
{
    return ::cvac::Labelable::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::Labelable::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::Labelable);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::Labelable::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::Labelable);
}

::IceProxy::Ice::Object*
IceProxy::cvac::Labelable::__newInstance() const
{
    return new Labelable;
}

const ::std::string&
IceProxy::cvac::Location::ice_staticId()
{
    return ::cvac::Location::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::Location::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::Location);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::Location::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::Location);
}

::IceProxy::Ice::Object*
IceProxy::cvac::Location::__newInstance() const
{
    return new Location;
}

const ::std::string&
IceProxy::cvac::Point2D::ice_staticId()
{
    return ::cvac::Point2D::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::Point2D::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::Point2D);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::Point2D::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::Point2D);
}

::IceProxy::Ice::Object*
IceProxy::cvac::Point2D::__newInstance() const
{
    return new Point2D;
}

const ::std::string&
IceProxy::cvac::BBox::ice_staticId()
{
    return ::cvac::BBox::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::BBox::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::BBox);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::BBox::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::BBox);
}

::IceProxy::Ice::Object*
IceProxy::cvac::BBox::__newInstance() const
{
    return new BBox;
}

const ::std::string&
IceProxy::cvac::PreciseLocation::ice_staticId()
{
    return ::cvac::PreciseLocation::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::PreciseLocation::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::PreciseLocation);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::PreciseLocation::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::PreciseLocation);
}

::IceProxy::Ice::Object*
IceProxy::cvac::PreciseLocation::__newInstance() const
{
    return new PreciseLocation;
}

const ::std::string&
IceProxy::cvac::PreciseBBox::ice_staticId()
{
    return ::cvac::PreciseBBox::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::PreciseBBox::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::PreciseBBox);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::PreciseBBox::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::PreciseBBox);
}

::IceProxy::Ice::Object*
IceProxy::cvac::PreciseBBox::__newInstance() const
{
    return new PreciseBBox;
}

const ::std::string&
IceProxy::cvac::PreciseCircle::ice_staticId()
{
    return ::cvac::PreciseCircle::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::PreciseCircle::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::PreciseCircle);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::PreciseCircle::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::PreciseCircle);
}

::IceProxy::Ice::Object*
IceProxy::cvac::PreciseCircle::__newInstance() const
{
    return new PreciseCircle;
}

const ::std::string&
IceProxy::cvac::Silhouette::ice_staticId()
{
    return ::cvac::Silhouette::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::Silhouette::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::Silhouette);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::Silhouette::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::Silhouette);
}

::IceProxy::Ice::Object*
IceProxy::cvac::Silhouette::__newInstance() const
{
    return new Silhouette;
}

const ::std::string&
IceProxy::cvac::LabeledFullSubstrate::ice_staticId()
{
    return ::cvac::LabeledFullSubstrate::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::LabeledFullSubstrate::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::LabeledFullSubstrate);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::LabeledFullSubstrate::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::LabeledFullSubstrate);
}

::IceProxy::Ice::Object*
IceProxy::cvac::LabeledFullSubstrate::__newInstance() const
{
    return new LabeledFullSubstrate;
}

const ::std::string&
IceProxy::cvac::LabeledLocation::ice_staticId()
{
    return ::cvac::LabeledLocation::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::LabeledLocation::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::LabeledLocation);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::LabeledLocation::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::LabeledLocation);
}

::IceProxy::Ice::Object*
IceProxy::cvac::LabeledLocation::__newInstance() const
{
    return new LabeledLocation;
}

const ::std::string&
IceProxy::cvac::LabeledVideoSegment::ice_staticId()
{
    return ::cvac::LabeledVideoSegment::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::LabeledVideoSegment::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::LabeledVideoSegment);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::LabeledVideoSegment::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::LabeledVideoSegment);
}

::IceProxy::Ice::Object*
IceProxy::cvac::LabeledVideoSegment::__newInstance() const
{
    return new LabeledVideoSegment;
}

const ::std::string&
IceProxy::cvac::LabeledTrack::ice_staticId()
{
    return ::cvac::LabeledTrack::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::cvac::LabeledTrack::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::cvac::LabeledTrack);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::cvac::LabeledTrack::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::cvac::LabeledTrack);
}

::IceProxy::Ice::Object*
IceProxy::cvac::LabeledTrack::__newInstance() const
{
    return new LabeledTrack;
}

cvac::PurposedList::PurposedList(const ::cvac::Purpose& __ice_pur) :
    pur(__ice_pur)
{
}

::Ice::ObjectPtr
cvac::PurposedList::ice_clone() const
{
    ::cvac::PurposedListPtr __p = new ::cvac::PurposedList(*this);
    return __p;
}

static const ::std::string __cvac__PurposedList_ids[2] =
{
    "::Ice::Object",
    "::cvac::PurposedList"
};

bool
cvac::PurposedList::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__PurposedList_ids, __cvac__PurposedList_ids + 2, _s);
}

::std::vector< ::std::string>
cvac::PurposedList::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__PurposedList_ids[0], &__cvac__PurposedList_ids[2]);
}

const ::std::string&
cvac::PurposedList::ice_id(const ::Ice::Current&) const
{
    return __cvac__PurposedList_ids[1];
}

const ::std::string&
cvac::PurposedList::ice_staticId()
{
    return __cvac__PurposedList_ids[1];
}

void
cvac::PurposedList::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    pur.__write(__os);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
cvac::PurposedList::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    pur.__read(__is);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::PurposedList::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PurposedList was not generated with stream support";
    throw ex;
}

void
cvac::PurposedList::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PurposedList was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__PurposedList : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::PurposedList::ice_staticId());
        return new ::cvac::PurposedList;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__PurposedList_Ptr = new __F__cvac__PurposedList;

const ::Ice::ObjectFactoryPtr&
cvac::PurposedList::ice_factory()
{
    return __F__cvac__PurposedList_Ptr;
}

class __F__cvac__PurposedList__Init
{
public:

    __F__cvac__PurposedList__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::PurposedList::ice_staticId(), ::cvac::PurposedList::ice_factory());
    }

    ~__F__cvac__PurposedList__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::PurposedList::ice_staticId());
    }
};

static __F__cvac__PurposedList__Init __F__cvac__PurposedList__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__PurposedList__initializer() {} }
#endif

void 
cvac::__patch__PurposedListPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::PurposedListPtr* p = static_cast< ::cvac::PurposedListPtr*>(__addr);
    assert(p);
    *p = ::cvac::PurposedListPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::PurposedList::ice_staticId(), v->ice_id());
    }
}

cvac::PurposedLabelableSeq::PurposedLabelableSeq(const ::cvac::Purpose& __ice_pur, const ::cvac::LabelableList& __ice_labeledArtifacts) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PurposedList(__ice_pur)
#else
    ::cvac::PurposedList(__ice_pur)
#endif
,
    labeledArtifacts(__ice_labeledArtifacts)
{
}

::Ice::ObjectPtr
cvac::PurposedLabelableSeq::ice_clone() const
{
    ::cvac::PurposedLabelableSeqPtr __p = new ::cvac::PurposedLabelableSeq(*this);
    return __p;
}

static const ::std::string __cvac__PurposedLabelableSeq_ids[3] =
{
    "::Ice::Object",
    "::cvac::PurposedLabelableSeq",
    "::cvac::PurposedList"
};

bool
cvac::PurposedLabelableSeq::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__PurposedLabelableSeq_ids, __cvac__PurposedLabelableSeq_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::PurposedLabelableSeq::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__PurposedLabelableSeq_ids[0], &__cvac__PurposedLabelableSeq_ids[3]);
}

const ::std::string&
cvac::PurposedLabelableSeq::ice_id(const ::Ice::Current&) const
{
    return __cvac__PurposedLabelableSeq_ids[1];
}

const ::std::string&
cvac::PurposedLabelableSeq::ice_staticId()
{
    return __cvac__PurposedLabelableSeq_ids[1];
}

void
cvac::PurposedLabelableSeq::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
cvac::PurposedLabelableSeq::__usesClasses()
{
    return true;
}

void
cvac::PurposedLabelableSeq::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::cvac::LabelableList::const_iterator _i0 = labeledArtifacts.begin(); _i0 != labeledArtifacts.end(); ++_i0)
        {
            if((*_i0))
            {
                ::IceInternal::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
}

void
cvac::PurposedLabelableSeq::__gcClear()
{
    {
        for(::cvac::LabelableList::iterator _i0 = labeledArtifacts.begin(); _i0 != labeledArtifacts.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::IceInternal::upCast((*_i0).get())->__usesClasses())
                {
                    ::IceInternal::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
cvac::PurposedLabelableSeq::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    if(labeledArtifacts.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::cvac::__writeLabelableList(__os, &labeledArtifacts[0], &labeledArtifacts[0] + labeledArtifacts.size());
    }
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PurposedList::__write(__os);
#else
    ::cvac::PurposedList::__write(__os);
#endif
}

void
cvac::PurposedLabelableSeq::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    ::cvac::__readLabelableList(__is, labeledArtifacts);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PurposedList::__read(__is, true);
#else
    ::cvac::PurposedList::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::PurposedLabelableSeq::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PurposedLabelableSeq was not generated with stream support";
    throw ex;
}

void
cvac::PurposedLabelableSeq::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PurposedLabelableSeq was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__PurposedLabelableSeq : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::PurposedLabelableSeq::ice_staticId());
        return new ::cvac::PurposedLabelableSeq;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__PurposedLabelableSeq_Ptr = new __F__cvac__PurposedLabelableSeq;

const ::Ice::ObjectFactoryPtr&
cvac::PurposedLabelableSeq::ice_factory()
{
    return __F__cvac__PurposedLabelableSeq_Ptr;
}

class __F__cvac__PurposedLabelableSeq__Init
{
public:

    __F__cvac__PurposedLabelableSeq__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::PurposedLabelableSeq::ice_staticId(), ::cvac::PurposedLabelableSeq::ice_factory());
    }

    ~__F__cvac__PurposedLabelableSeq__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::PurposedLabelableSeq::ice_staticId());
    }
};

static __F__cvac__PurposedLabelableSeq__Init __F__cvac__PurposedLabelableSeq__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__PurposedLabelableSeq__initializer() {} }
#endif

void 
cvac::__patch__PurposedLabelableSeqPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::PurposedLabelableSeqPtr* p = static_cast< ::cvac::PurposedLabelableSeqPtr*>(__addr);
    assert(p);
    *p = ::cvac::PurposedLabelableSeqPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::PurposedLabelableSeq::ice_staticId(), v->ice_id());
    }
}

cvac::PurposedDirectory::PurposedDirectory(const ::cvac::Purpose& __ice_pur, const ::cvac::DirectoryPath& __ice_directory, const ::cvac::StringList& __ice_fileSuffixes, bool __ice_recursive) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PurposedList(__ice_pur)
#else
    ::cvac::PurposedList(__ice_pur)
#endif
,
    directory(__ice_directory),
    fileSuffixes(__ice_fileSuffixes),
    recursive(__ice_recursive)
{
}

::Ice::ObjectPtr
cvac::PurposedDirectory::ice_clone() const
{
    ::cvac::PurposedDirectoryPtr __p = new ::cvac::PurposedDirectory(*this);
    return __p;
}

static const ::std::string __cvac__PurposedDirectory_ids[3] =
{
    "::Ice::Object",
    "::cvac::PurposedDirectory",
    "::cvac::PurposedList"
};

bool
cvac::PurposedDirectory::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__PurposedDirectory_ids, __cvac__PurposedDirectory_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::PurposedDirectory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__PurposedDirectory_ids[0], &__cvac__PurposedDirectory_ids[3]);
}

const ::std::string&
cvac::PurposedDirectory::ice_id(const ::Ice::Current&) const
{
    return __cvac__PurposedDirectory_ids[1];
}

const ::std::string&
cvac::PurposedDirectory::ice_staticId()
{
    return __cvac__PurposedDirectory_ids[1];
}

void
cvac::PurposedDirectory::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    directory.__write(__os);
    if(fileSuffixes.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        __os->write(&fileSuffixes[0], &fileSuffixes[0] + fileSuffixes.size());
    }
    __os->write(recursive);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PurposedList::__write(__os);
#else
    ::cvac::PurposedList::__write(__os);
#endif
}

void
cvac::PurposedDirectory::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    directory.__read(__is);
    __is->read(fileSuffixes);
    __is->read(recursive);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PurposedList::__read(__is, true);
#else
    ::cvac::PurposedList::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::PurposedDirectory::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PurposedDirectory was not generated with stream support";
    throw ex;
}

void
cvac::PurposedDirectory::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PurposedDirectory was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__PurposedDirectory : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::PurposedDirectory::ice_staticId());
        return new ::cvac::PurposedDirectory;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__PurposedDirectory_Ptr = new __F__cvac__PurposedDirectory;

const ::Ice::ObjectFactoryPtr&
cvac::PurposedDirectory::ice_factory()
{
    return __F__cvac__PurposedDirectory_Ptr;
}

class __F__cvac__PurposedDirectory__Init
{
public:

    __F__cvac__PurposedDirectory__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::PurposedDirectory::ice_staticId(), ::cvac::PurposedDirectory::ice_factory());
    }

    ~__F__cvac__PurposedDirectory__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::PurposedDirectory::ice_staticId());
    }
};

static __F__cvac__PurposedDirectory__Init __F__cvac__PurposedDirectory__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__PurposedDirectory__initializer() {} }
#endif

void 
cvac::__patch__PurposedDirectoryPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::PurposedDirectoryPtr* p = static_cast< ::cvac::PurposedDirectoryPtr*>(__addr);
    assert(p);
    *p = ::cvac::PurposedDirectoryPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::PurposedDirectory::ice_staticId(), v->ice_id());
    }
}

cvac::Labelable::Labelable(::Ice::Float __ice_confidence, const ::cvac::Label& __ice_lab, const ::cvac::Substrate& __ice_sub) :
    confidence(__ice_confidence),
    lab(__ice_lab),
    sub(__ice_sub)
{
}

::Ice::ObjectPtr
cvac::Labelable::ice_clone() const
{
    ::cvac::LabelablePtr __p = new ::cvac::Labelable(*this);
    return __p;
}

static const ::std::string __cvac__Labelable_ids[2] =
{
    "::Ice::Object",
    "::cvac::Labelable"
};

bool
cvac::Labelable::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__Labelable_ids, __cvac__Labelable_ids + 2, _s);
}

::std::vector< ::std::string>
cvac::Labelable::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__Labelable_ids[0], &__cvac__Labelable_ids[2]);
}

const ::std::string&
cvac::Labelable::ice_id(const ::Ice::Current&) const
{
    return __cvac__Labelable_ids[1];
}

const ::std::string&
cvac::Labelable::ice_staticId()
{
    return __cvac__Labelable_ids[1];
}

void
cvac::Labelable::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(confidence);
    lab.__write(__os);
    sub.__write(__os);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
cvac::Labelable::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(confidence);
    lab.__read(__is);
    sub.__read(__is);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::Labelable::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::Labelable was not generated with stream support";
    throw ex;
}

void
cvac::Labelable::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::Labelable was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__Labelable : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::Labelable::ice_staticId());
        return new ::cvac::Labelable;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__Labelable_Ptr = new __F__cvac__Labelable;

const ::Ice::ObjectFactoryPtr&
cvac::Labelable::ice_factory()
{
    return __F__cvac__Labelable_Ptr;
}

class __F__cvac__Labelable__Init
{
public:

    __F__cvac__Labelable__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::Labelable::ice_staticId(), ::cvac::Labelable::ice_factory());
    }

    ~__F__cvac__Labelable__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::Labelable::ice_staticId());
    }
};

static __F__cvac__Labelable__Init __F__cvac__Labelable__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__Labelable__initializer() {} }
#endif

void 
cvac::__patch__LabelablePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::LabelablePtr* p = static_cast< ::cvac::LabelablePtr*>(__addr);
    assert(p);
    *p = ::cvac::LabelablePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::Labelable::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
cvac::Location::ice_clone() const
{
    ::cvac::LocationPtr __p = new ::cvac::Location(*this);
    return __p;
}

static const ::std::string __cvac__Location_ids[2] =
{
    "::Ice::Object",
    "::cvac::Location"
};

bool
cvac::Location::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__Location_ids, __cvac__Location_ids + 2, _s);
}

::std::vector< ::std::string>
cvac::Location::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__Location_ids[0], &__cvac__Location_ids[2]);
}

const ::std::string&
cvac::Location::ice_id(const ::Ice::Current&) const
{
    return __cvac__Location_ids[1];
}

const ::std::string&
cvac::Location::ice_staticId()
{
    return __cvac__Location_ids[1];
}

void
cvac::Location::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
cvac::Location::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::Location::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::Location was not generated with stream support";
    throw ex;
}

void
cvac::Location::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::Location was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__Location : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::Location::ice_staticId());
        return new ::cvac::Location;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__Location_Ptr = new __F__cvac__Location;

const ::Ice::ObjectFactoryPtr&
cvac::Location::ice_factory()
{
    return __F__cvac__Location_Ptr;
}

class __F__cvac__Location__Init
{
public:

    __F__cvac__Location__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::Location::ice_staticId(), ::cvac::Location::ice_factory());
    }

    ~__F__cvac__Location__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::Location::ice_staticId());
    }
};

static __F__cvac__Location__Init __F__cvac__Location__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__Location__initializer() {} }
#endif

void 
cvac::__patch__LocationPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::LocationPtr* p = static_cast< ::cvac::LocationPtr*>(__addr);
    assert(p);
    *p = ::cvac::LocationPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::Location::ice_staticId(), v->ice_id());
    }
}

cvac::Point2D::Point2D(::Ice::Int __ice_x, ::Ice::Int __ice_y) :
    x(__ice_x),
    y(__ice_y)
{
}

::Ice::ObjectPtr
cvac::Point2D::ice_clone() const
{
    ::cvac::Point2DPtr __p = new ::cvac::Point2D(*this);
    return __p;
}

static const ::std::string __cvac__Point2D_ids[3] =
{
    "::Ice::Object",
    "::cvac::Location",
    "::cvac::Point2D"
};

bool
cvac::Point2D::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__Point2D_ids, __cvac__Point2D_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::Point2D::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__Point2D_ids[0], &__cvac__Point2D_ids[3]);
}

const ::std::string&
cvac::Point2D::ice_id(const ::Ice::Current&) const
{
    return __cvac__Point2D_ids[2];
}

const ::std::string&
cvac::Point2D::ice_staticId()
{
    return __cvac__Point2D_ids[2];
}

void
cvac::Point2D::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(x);
    __os->write(y);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Location::__write(__os);
#else
    ::cvac::Location::__write(__os);
#endif
}

void
cvac::Point2D::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(x);
    __is->read(y);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Location::__read(__is, true);
#else
    ::cvac::Location::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::Point2D::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::Point2D was not generated with stream support";
    throw ex;
}

void
cvac::Point2D::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::Point2D was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__Point2D : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::Point2D::ice_staticId());
        return new ::cvac::Point2D;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__Point2D_Ptr = new __F__cvac__Point2D;

const ::Ice::ObjectFactoryPtr&
cvac::Point2D::ice_factory()
{
    return __F__cvac__Point2D_Ptr;
}

class __F__cvac__Point2D__Init
{
public:

    __F__cvac__Point2D__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::Point2D::ice_staticId(), ::cvac::Point2D::ice_factory());
    }

    ~__F__cvac__Point2D__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::Point2D::ice_staticId());
    }
};

static __F__cvac__Point2D__Init __F__cvac__Point2D__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__Point2D__initializer() {} }
#endif

void 
cvac::__patch__Point2DPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::Point2DPtr* p = static_cast< ::cvac::Point2DPtr*>(__addr);
    assert(p);
    *p = ::cvac::Point2DPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::Point2D::ice_staticId(), v->ice_id());
    }
}

cvac::BBox::BBox(::Ice::Int __ice_x, ::Ice::Int __ice_y, ::Ice::Int __ice_width, ::Ice::Int __ice_height) :
    x(__ice_x),
    y(__ice_y),
    width(__ice_width),
    height(__ice_height)
{
}

::Ice::ObjectPtr
cvac::BBox::ice_clone() const
{
    ::cvac::BBoxPtr __p = new ::cvac::BBox(*this);
    return __p;
}

static const ::std::string __cvac__BBox_ids[3] =
{
    "::Ice::Object",
    "::cvac::BBox",
    "::cvac::Location"
};

bool
cvac::BBox::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__BBox_ids, __cvac__BBox_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::BBox::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__BBox_ids[0], &__cvac__BBox_ids[3]);
}

const ::std::string&
cvac::BBox::ice_id(const ::Ice::Current&) const
{
    return __cvac__BBox_ids[1];
}

const ::std::string&
cvac::BBox::ice_staticId()
{
    return __cvac__BBox_ids[1];
}

void
cvac::BBox::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(x);
    __os->write(y);
    __os->write(width);
    __os->write(height);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Location::__write(__os);
#else
    ::cvac::Location::__write(__os);
#endif
}

void
cvac::BBox::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(x);
    __is->read(y);
    __is->read(width);
    __is->read(height);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Location::__read(__is, true);
#else
    ::cvac::Location::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::BBox::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::BBox was not generated with stream support";
    throw ex;
}

void
cvac::BBox::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::BBox was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__BBox : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::BBox::ice_staticId());
        return new ::cvac::BBox;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__BBox_Ptr = new __F__cvac__BBox;

const ::Ice::ObjectFactoryPtr&
cvac::BBox::ice_factory()
{
    return __F__cvac__BBox_Ptr;
}

class __F__cvac__BBox__Init
{
public:

    __F__cvac__BBox__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::BBox::ice_staticId(), ::cvac::BBox::ice_factory());
    }

    ~__F__cvac__BBox__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::BBox::ice_staticId());
    }
};

static __F__cvac__BBox__Init __F__cvac__BBox__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__BBox__initializer() {} }
#endif

void 
cvac::__patch__BBoxPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::BBoxPtr* p = static_cast< ::cvac::BBoxPtr*>(__addr);
    assert(p);
    *p = ::cvac::BBoxPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::BBox::ice_staticId(), v->ice_id());
    }
}

cvac::PreciseLocation::PreciseLocation(::Ice::Float __ice_centerX, ::Ice::Float __ice_centerY) :
    centerX(__ice_centerX),
    centerY(__ice_centerY)
{
}

::Ice::ObjectPtr
cvac::PreciseLocation::ice_clone() const
{
    ::cvac::PreciseLocationPtr __p = new ::cvac::PreciseLocation(*this);
    return __p;
}

static const ::std::string __cvac__PreciseLocation_ids[3] =
{
    "::Ice::Object",
    "::cvac::Location",
    "::cvac::PreciseLocation"
};

bool
cvac::PreciseLocation::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__PreciseLocation_ids, __cvac__PreciseLocation_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::PreciseLocation::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__PreciseLocation_ids[0], &__cvac__PreciseLocation_ids[3]);
}

const ::std::string&
cvac::PreciseLocation::ice_id(const ::Ice::Current&) const
{
    return __cvac__PreciseLocation_ids[2];
}

const ::std::string&
cvac::PreciseLocation::ice_staticId()
{
    return __cvac__PreciseLocation_ids[2];
}

void
cvac::PreciseLocation::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(centerX);
    __os->write(centerY);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Location::__write(__os);
#else
    ::cvac::Location::__write(__os);
#endif
}

void
cvac::PreciseLocation::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(centerX);
    __is->read(centerY);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Location::__read(__is, true);
#else
    ::cvac::Location::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::PreciseLocation::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PreciseLocation was not generated with stream support";
    throw ex;
}

void
cvac::PreciseLocation::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PreciseLocation was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__PreciseLocation : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::PreciseLocation::ice_staticId());
        return new ::cvac::PreciseLocation;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__PreciseLocation_Ptr = new __F__cvac__PreciseLocation;

const ::Ice::ObjectFactoryPtr&
cvac::PreciseLocation::ice_factory()
{
    return __F__cvac__PreciseLocation_Ptr;
}

class __F__cvac__PreciseLocation__Init
{
public:

    __F__cvac__PreciseLocation__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::PreciseLocation::ice_staticId(), ::cvac::PreciseLocation::ice_factory());
    }

    ~__F__cvac__PreciseLocation__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::PreciseLocation::ice_staticId());
    }
};

static __F__cvac__PreciseLocation__Init __F__cvac__PreciseLocation__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__PreciseLocation__initializer() {} }
#endif

void 
cvac::__patch__PreciseLocationPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::PreciseLocationPtr* p = static_cast< ::cvac::PreciseLocationPtr*>(__addr);
    assert(p);
    *p = ::cvac::PreciseLocationPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::PreciseLocation::ice_staticId(), v->ice_id());
    }
}

cvac::PreciseBBox::PreciseBBox(::Ice::Float __ice_centerX, ::Ice::Float __ice_centerY, ::Ice::Float __ice_width, ::Ice::Float __ice_height) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PreciseLocation(__ice_centerX, __ice_centerY)
#else
    ::cvac::PreciseLocation(__ice_centerX, __ice_centerY)
#endif
,
    width(__ice_width),
    height(__ice_height)
{
}

::Ice::ObjectPtr
cvac::PreciseBBox::ice_clone() const
{
    ::cvac::PreciseBBoxPtr __p = new ::cvac::PreciseBBox(*this);
    return __p;
}

static const ::std::string __cvac__PreciseBBox_ids[4] =
{
    "::Ice::Object",
    "::cvac::Location",
    "::cvac::PreciseBBox",
    "::cvac::PreciseLocation"
};

bool
cvac::PreciseBBox::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__PreciseBBox_ids, __cvac__PreciseBBox_ids + 4, _s);
}

::std::vector< ::std::string>
cvac::PreciseBBox::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__PreciseBBox_ids[0], &__cvac__PreciseBBox_ids[4]);
}

const ::std::string&
cvac::PreciseBBox::ice_id(const ::Ice::Current&) const
{
    return __cvac__PreciseBBox_ids[2];
}

const ::std::string&
cvac::PreciseBBox::ice_staticId()
{
    return __cvac__PreciseBBox_ids[2];
}

void
cvac::PreciseBBox::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(width);
    __os->write(height);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PreciseLocation::__write(__os);
#else
    ::cvac::PreciseLocation::__write(__os);
#endif
}

void
cvac::PreciseBBox::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(width);
    __is->read(height);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PreciseLocation::__read(__is, true);
#else
    ::cvac::PreciseLocation::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::PreciseBBox::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PreciseBBox was not generated with stream support";
    throw ex;
}

void
cvac::PreciseBBox::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PreciseBBox was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__PreciseBBox : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::PreciseBBox::ice_staticId());
        return new ::cvac::PreciseBBox;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__PreciseBBox_Ptr = new __F__cvac__PreciseBBox;

const ::Ice::ObjectFactoryPtr&
cvac::PreciseBBox::ice_factory()
{
    return __F__cvac__PreciseBBox_Ptr;
}

class __F__cvac__PreciseBBox__Init
{
public:

    __F__cvac__PreciseBBox__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::PreciseBBox::ice_staticId(), ::cvac::PreciseBBox::ice_factory());
    }

    ~__F__cvac__PreciseBBox__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::PreciseBBox::ice_staticId());
    }
};

static __F__cvac__PreciseBBox__Init __F__cvac__PreciseBBox__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__PreciseBBox__initializer() {} }
#endif

void 
cvac::__patch__PreciseBBoxPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::PreciseBBoxPtr* p = static_cast< ::cvac::PreciseBBoxPtr*>(__addr);
    assert(p);
    *p = ::cvac::PreciseBBoxPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::PreciseBBox::ice_staticId(), v->ice_id());
    }
}

cvac::PreciseCircle::PreciseCircle(::Ice::Float __ice_centerX, ::Ice::Float __ice_centerY, ::Ice::Float __ice_radius) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PreciseLocation(__ice_centerX, __ice_centerY)
#else
    ::cvac::PreciseLocation(__ice_centerX, __ice_centerY)
#endif
,
    radius(__ice_radius)
{
}

::Ice::ObjectPtr
cvac::PreciseCircle::ice_clone() const
{
    ::cvac::PreciseCirclePtr __p = new ::cvac::PreciseCircle(*this);
    return __p;
}

static const ::std::string __cvac__PreciseCircle_ids[4] =
{
    "::Ice::Object",
    "::cvac::Location",
    "::cvac::PreciseCircle",
    "::cvac::PreciseLocation"
};

bool
cvac::PreciseCircle::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__PreciseCircle_ids, __cvac__PreciseCircle_ids + 4, _s);
}

::std::vector< ::std::string>
cvac::PreciseCircle::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__PreciseCircle_ids[0], &__cvac__PreciseCircle_ids[4]);
}

const ::std::string&
cvac::PreciseCircle::ice_id(const ::Ice::Current&) const
{
    return __cvac__PreciseCircle_ids[2];
}

const ::std::string&
cvac::PreciseCircle::ice_staticId()
{
    return __cvac__PreciseCircle_ids[2];
}

void
cvac::PreciseCircle::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(radius);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PreciseLocation::__write(__os);
#else
    ::cvac::PreciseLocation::__write(__os);
#endif
}

void
cvac::PreciseCircle::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(radius);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    PreciseLocation::__read(__is, true);
#else
    ::cvac::PreciseLocation::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::PreciseCircle::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PreciseCircle was not generated with stream support";
    throw ex;
}

void
cvac::PreciseCircle::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::PreciseCircle was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__PreciseCircle : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::PreciseCircle::ice_staticId());
        return new ::cvac::PreciseCircle;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__PreciseCircle_Ptr = new __F__cvac__PreciseCircle;

const ::Ice::ObjectFactoryPtr&
cvac::PreciseCircle::ice_factory()
{
    return __F__cvac__PreciseCircle_Ptr;
}

class __F__cvac__PreciseCircle__Init
{
public:

    __F__cvac__PreciseCircle__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::PreciseCircle::ice_staticId(), ::cvac::PreciseCircle::ice_factory());
    }

    ~__F__cvac__PreciseCircle__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::PreciseCircle::ice_staticId());
    }
};

static __F__cvac__PreciseCircle__Init __F__cvac__PreciseCircle__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__PreciseCircle__initializer() {} }
#endif

void 
cvac::__patch__PreciseCirclePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::PreciseCirclePtr* p = static_cast< ::cvac::PreciseCirclePtr*>(__addr);
    assert(p);
    *p = ::cvac::PreciseCirclePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::PreciseCircle::ice_staticId(), v->ice_id());
    }
}

cvac::Silhouette::Silhouette(const ::cvac::Point2DList& __ice_points) :
    points(__ice_points)
{
}

::Ice::ObjectPtr
cvac::Silhouette::ice_clone() const
{
    ::cvac::SilhouettePtr __p = new ::cvac::Silhouette(*this);
    return __p;
}

static const ::std::string __cvac__Silhouette_ids[3] =
{
    "::Ice::Object",
    "::cvac::Location",
    "::cvac::Silhouette"
};

bool
cvac::Silhouette::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__Silhouette_ids, __cvac__Silhouette_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::Silhouette::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__Silhouette_ids[0], &__cvac__Silhouette_ids[3]);
}

const ::std::string&
cvac::Silhouette::ice_id(const ::Ice::Current&) const
{
    return __cvac__Silhouette_ids[2];
}

const ::std::string&
cvac::Silhouette::ice_staticId()
{
    return __cvac__Silhouette_ids[2];
}

void
cvac::Silhouette::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
cvac::Silhouette::__usesClasses()
{
    return true;
}

void
cvac::Silhouette::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::cvac::Point2DList::const_iterator _i0 = points.begin(); _i0 != points.end(); ++_i0)
        {
            if((*_i0))
            {
                ::IceInternal::upCast((*_i0).get())->__addObject(_c);
            }
        }
    }
}

void
cvac::Silhouette::__gcClear()
{
    {
        for(::cvac::Point2DList::iterator _i0 = points.begin(); _i0 != points.end(); ++_i0)
        {
            if((*_i0))
            {
                if(::IceInternal::upCast((*_i0).get())->__usesClasses())
                {
                    ::IceInternal::upCast((*_i0).get())->__decRefUnsafe();
                    (*_i0).__clearHandleUnsafe();
                }
                else
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
cvac::Silhouette::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    if(points.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::cvac::__writePoint2DList(__os, &points[0], &points[0] + points.size());
    }
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Location::__write(__os);
#else
    ::cvac::Location::__write(__os);
#endif
}

void
cvac::Silhouette::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    ::cvac::__readPoint2DList(__is, points);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Location::__read(__is, true);
#else
    ::cvac::Location::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::Silhouette::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::Silhouette was not generated with stream support";
    throw ex;
}

void
cvac::Silhouette::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::Silhouette was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__Silhouette : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::Silhouette::ice_staticId());
        return new ::cvac::Silhouette;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__Silhouette_Ptr = new __F__cvac__Silhouette;

const ::Ice::ObjectFactoryPtr&
cvac::Silhouette::ice_factory()
{
    return __F__cvac__Silhouette_Ptr;
}

class __F__cvac__Silhouette__Init
{
public:

    __F__cvac__Silhouette__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::Silhouette::ice_staticId(), ::cvac::Silhouette::ice_factory());
    }

    ~__F__cvac__Silhouette__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::Silhouette::ice_staticId());
    }
};

static __F__cvac__Silhouette__Init __F__cvac__Silhouette__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__Silhouette__initializer() {} }
#endif

void 
cvac::__patch__SilhouettePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::SilhouettePtr* p = static_cast< ::cvac::SilhouettePtr*>(__addr);
    assert(p);
    *p = ::cvac::SilhouettePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::Silhouette::ice_staticId(), v->ice_id());
    }
}

cvac::LabeledFullSubstrate::LabeledFullSubstrate(::Ice::Float __ice_confidence, const ::cvac::Label& __ice_lab, const ::cvac::Substrate& __ice_sub) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable(__ice_confidence, __ice_lab, __ice_sub)
#else
    ::cvac::Labelable(__ice_confidence, __ice_lab, __ice_sub)
#endif

{
}

::Ice::ObjectPtr
cvac::LabeledFullSubstrate::ice_clone() const
{
    ::cvac::LabeledFullSubstratePtr __p = new ::cvac::LabeledFullSubstrate(*this);
    return __p;
}

static const ::std::string __cvac__LabeledFullSubstrate_ids[3] =
{
    "::Ice::Object",
    "::cvac::Labelable",
    "::cvac::LabeledFullSubstrate"
};

bool
cvac::LabeledFullSubstrate::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__LabeledFullSubstrate_ids, __cvac__LabeledFullSubstrate_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::LabeledFullSubstrate::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__LabeledFullSubstrate_ids[0], &__cvac__LabeledFullSubstrate_ids[3]);
}

const ::std::string&
cvac::LabeledFullSubstrate::ice_id(const ::Ice::Current&) const
{
    return __cvac__LabeledFullSubstrate_ids[2];
}

const ::std::string&
cvac::LabeledFullSubstrate::ice_staticId()
{
    return __cvac__LabeledFullSubstrate_ids[2];
}

void
cvac::LabeledFullSubstrate::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable::__write(__os);
#else
    ::cvac::Labelable::__write(__os);
#endif
}

void
cvac::LabeledFullSubstrate::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable::__read(__is, true);
#else
    ::cvac::Labelable::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::LabeledFullSubstrate::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::LabeledFullSubstrate was not generated with stream support";
    throw ex;
}

void
cvac::LabeledFullSubstrate::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::LabeledFullSubstrate was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__LabeledFullSubstrate : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::LabeledFullSubstrate::ice_staticId());
        return new ::cvac::LabeledFullSubstrate;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__LabeledFullSubstrate_Ptr = new __F__cvac__LabeledFullSubstrate;

const ::Ice::ObjectFactoryPtr&
cvac::LabeledFullSubstrate::ice_factory()
{
    return __F__cvac__LabeledFullSubstrate_Ptr;
}

class __F__cvac__LabeledFullSubstrate__Init
{
public:

    __F__cvac__LabeledFullSubstrate__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::LabeledFullSubstrate::ice_staticId(), ::cvac::LabeledFullSubstrate::ice_factory());
    }

    ~__F__cvac__LabeledFullSubstrate__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::LabeledFullSubstrate::ice_staticId());
    }
};

static __F__cvac__LabeledFullSubstrate__Init __F__cvac__LabeledFullSubstrate__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__LabeledFullSubstrate__initializer() {} }
#endif

void 
cvac::__patch__LabeledFullSubstratePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::LabeledFullSubstratePtr* p = static_cast< ::cvac::LabeledFullSubstratePtr*>(__addr);
    assert(p);
    *p = ::cvac::LabeledFullSubstratePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::LabeledFullSubstrate::ice_staticId(), v->ice_id());
    }
}

cvac::LabeledLocation::LabeledLocation(::Ice::Float __ice_confidence, const ::cvac::Label& __ice_lab, const ::cvac::Substrate& __ice_sub, const ::cvac::LocationPtr& __ice_loc) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable(__ice_confidence, __ice_lab, __ice_sub)
#else
    ::cvac::Labelable(__ice_confidence, __ice_lab, __ice_sub)
#endif
,
    loc(__ice_loc)
{
}

::Ice::ObjectPtr
cvac::LabeledLocation::ice_clone() const
{
    ::cvac::LabeledLocationPtr __p = new ::cvac::LabeledLocation(*this);
    return __p;
}

static const ::std::string __cvac__LabeledLocation_ids[3] =
{
    "::Ice::Object",
    "::cvac::Labelable",
    "::cvac::LabeledLocation"
};

bool
cvac::LabeledLocation::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__LabeledLocation_ids, __cvac__LabeledLocation_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::LabeledLocation::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__LabeledLocation_ids[0], &__cvac__LabeledLocation_ids[3]);
}

const ::std::string&
cvac::LabeledLocation::ice_id(const ::Ice::Current&) const
{
    return __cvac__LabeledLocation_ids[2];
}

const ::std::string&
cvac::LabeledLocation::ice_staticId()
{
    return __cvac__LabeledLocation_ids[2];
}

void
cvac::LabeledLocation::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
cvac::LabeledLocation::__usesClasses()
{
    return true;
}

void
cvac::LabeledLocation::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(loc)
    {
        ::IceInternal::upCast(loc.get())->__addObject(_c);
    }
}

void
cvac::LabeledLocation::__gcClear()
{
    if(loc)
    {
        if(::IceInternal::upCast(loc.get())->__usesClasses())
        {
            ::IceInternal::upCast(loc.get())->__decRefUnsafe();
            loc.__clearHandleUnsafe();
        }
        else
        {
            loc = 0;
        }
    }
}

void
cvac::LabeledLocation::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(::Ice::ObjectPtr(::IceInternal::upCast(loc.get())));
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable::__write(__os);
#else
    ::cvac::Labelable::__write(__os);
#endif
}

void
cvac::LabeledLocation::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(::cvac::__patch__LocationPtr, &loc);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable::__read(__is, true);
#else
    ::cvac::Labelable::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::LabeledLocation::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::LabeledLocation was not generated with stream support";
    throw ex;
}

void
cvac::LabeledLocation::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::LabeledLocation was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__LabeledLocation : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::LabeledLocation::ice_staticId());
        return new ::cvac::LabeledLocation;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__LabeledLocation_Ptr = new __F__cvac__LabeledLocation;

const ::Ice::ObjectFactoryPtr&
cvac::LabeledLocation::ice_factory()
{
    return __F__cvac__LabeledLocation_Ptr;
}

class __F__cvac__LabeledLocation__Init
{
public:

    __F__cvac__LabeledLocation__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::LabeledLocation::ice_staticId(), ::cvac::LabeledLocation::ice_factory());
    }

    ~__F__cvac__LabeledLocation__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::LabeledLocation::ice_staticId());
    }
};

static __F__cvac__LabeledLocation__Init __F__cvac__LabeledLocation__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__LabeledLocation__initializer() {} }
#endif

void 
cvac::__patch__LabeledLocationPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::LabeledLocationPtr* p = static_cast< ::cvac::LabeledLocationPtr*>(__addr);
    assert(p);
    *p = ::cvac::LabeledLocationPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::LabeledLocation::ice_staticId(), v->ice_id());
    }
}

cvac::LabeledVideoSegment::LabeledVideoSegment(::Ice::Float __ice_confidence, const ::cvac::Label& __ice_lab, const ::cvac::Substrate& __ice_sub, const ::cvac::VideoSeekTime& __ice_start, const ::cvac::VideoSeekTime& __ice_last, const ::cvac::VideoSeekTime& __ice_startAfterTx, const ::cvac::VideoSeekTime& __ice_lastBeforeTx, const ::cvac::LocationPtr& __ice_loc) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable(__ice_confidence, __ice_lab, __ice_sub)
#else
    ::cvac::Labelable(__ice_confidence, __ice_lab, __ice_sub)
#endif
,
    start(__ice_start),
    last(__ice_last),
    startAfterTx(__ice_startAfterTx),
    lastBeforeTx(__ice_lastBeforeTx),
    loc(__ice_loc)
{
}

::Ice::ObjectPtr
cvac::LabeledVideoSegment::ice_clone() const
{
    ::cvac::LabeledVideoSegmentPtr __p = new ::cvac::LabeledVideoSegment(*this);
    return __p;
}

static const ::std::string __cvac__LabeledVideoSegment_ids[3] =
{
    "::Ice::Object",
    "::cvac::Labelable",
    "::cvac::LabeledVideoSegment"
};

bool
cvac::LabeledVideoSegment::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__LabeledVideoSegment_ids, __cvac__LabeledVideoSegment_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::LabeledVideoSegment::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__LabeledVideoSegment_ids[0], &__cvac__LabeledVideoSegment_ids[3]);
}

const ::std::string&
cvac::LabeledVideoSegment::ice_id(const ::Ice::Current&) const
{
    return __cvac__LabeledVideoSegment_ids[2];
}

const ::std::string&
cvac::LabeledVideoSegment::ice_staticId()
{
    return __cvac__LabeledVideoSegment_ids[2];
}

void
cvac::LabeledVideoSegment::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
cvac::LabeledVideoSegment::__usesClasses()
{
    return true;
}

void
cvac::LabeledVideoSegment::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    if(loc)
    {
        ::IceInternal::upCast(loc.get())->__addObject(_c);
    }
}

void
cvac::LabeledVideoSegment::__gcClear()
{
    if(loc)
    {
        if(::IceInternal::upCast(loc.get())->__usesClasses())
        {
            ::IceInternal::upCast(loc.get())->__decRefUnsafe();
            loc.__clearHandleUnsafe();
        }
        else
        {
            loc = 0;
        }
    }
}

void
cvac::LabeledVideoSegment::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    start.__write(__os);
    last.__write(__os);
    startAfterTx.__write(__os);
    lastBeforeTx.__write(__os);
    __os->write(::Ice::ObjectPtr(::IceInternal::upCast(loc.get())));
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable::__write(__os);
#else
    ::cvac::Labelable::__write(__os);
#endif
}

void
cvac::LabeledVideoSegment::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    start.__read(__is);
    last.__read(__is);
    startAfterTx.__read(__is);
    lastBeforeTx.__read(__is);
    __is->read(::cvac::__patch__LocationPtr, &loc);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable::__read(__is, true);
#else
    ::cvac::Labelable::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::LabeledVideoSegment::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::LabeledVideoSegment was not generated with stream support";
    throw ex;
}

void
cvac::LabeledVideoSegment::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::LabeledVideoSegment was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__LabeledVideoSegment : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::LabeledVideoSegment::ice_staticId());
        return new ::cvac::LabeledVideoSegment;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__LabeledVideoSegment_Ptr = new __F__cvac__LabeledVideoSegment;

const ::Ice::ObjectFactoryPtr&
cvac::LabeledVideoSegment::ice_factory()
{
    return __F__cvac__LabeledVideoSegment_Ptr;
}

class __F__cvac__LabeledVideoSegment__Init
{
public:

    __F__cvac__LabeledVideoSegment__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::LabeledVideoSegment::ice_staticId(), ::cvac::LabeledVideoSegment::ice_factory());
    }

    ~__F__cvac__LabeledVideoSegment__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::LabeledVideoSegment::ice_staticId());
    }
};

static __F__cvac__LabeledVideoSegment__Init __F__cvac__LabeledVideoSegment__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__LabeledVideoSegment__initializer() {} }
#endif

void 
cvac::__patch__LabeledVideoSegmentPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::LabeledVideoSegmentPtr* p = static_cast< ::cvac::LabeledVideoSegmentPtr*>(__addr);
    assert(p);
    *p = ::cvac::LabeledVideoSegmentPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::LabeledVideoSegment::ice_staticId(), v->ice_id());
    }
}

cvac::LabeledTrack::LabeledTrack(::Ice::Float __ice_confidence, const ::cvac::Label& __ice_lab, const ::cvac::Substrate& __ice_sub, const ::cvac::FrameLocationList& __ice_keyframesLocations, ::cvac::Interpolation __ice_interp) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable(__ice_confidence, __ice_lab, __ice_sub)
#else
    ::cvac::Labelable(__ice_confidence, __ice_lab, __ice_sub)
#endif
,
    keyframesLocations(__ice_keyframesLocations),
    interp(__ice_interp)
{
}

::Ice::ObjectPtr
cvac::LabeledTrack::ice_clone() const
{
    ::cvac::LabeledTrackPtr __p = new ::cvac::LabeledTrack(*this);
    return __p;
}

static const ::std::string __cvac__LabeledTrack_ids[3] =
{
    "::Ice::Object",
    "::cvac::Labelable",
    "::cvac::LabeledTrack"
};

bool
cvac::LabeledTrack::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__cvac__LabeledTrack_ids, __cvac__LabeledTrack_ids + 3, _s);
}

::std::vector< ::std::string>
cvac::LabeledTrack::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__cvac__LabeledTrack_ids[0], &__cvac__LabeledTrack_ids[3]);
}

const ::std::string&
cvac::LabeledTrack::ice_id(const ::Ice::Current&) const
{
    return __cvac__LabeledTrack_ids[2];
}

const ::std::string&
cvac::LabeledTrack::ice_staticId()
{
    return __cvac__LabeledTrack_ids[2];
}

void
cvac::LabeledTrack::__addObject(::IceInternal::GCCountMap& _c)
{
    ::IceInternal::GCCountMap::iterator pos = _c.find(this);
    if(pos == _c.end())
    {
        _c[this] = 1;
    }
    else
    {
        ++pos->second;
    }
}

bool
cvac::LabeledTrack::__usesClasses()
{
    return true;
}

void
cvac::LabeledTrack::__gcReachable(::IceInternal::GCCountMap& _c) const
{
    {
        for(::cvac::FrameLocationList::const_iterator _i0 = keyframesLocations.begin(); _i0 != keyframesLocations.end(); ++_i0)
        {
            if((*_i0).loc)
            {
                ::IceInternal::upCast((*_i0).loc.get())->__addObject(_c);
            }
        }
    }
}

void
cvac::LabeledTrack::__gcClear()
{
    {
        for(::cvac::FrameLocationList::iterator _i0 = keyframesLocations.begin(); _i0 != keyframesLocations.end(); ++_i0)
        {
            if((*_i0).loc)
            {
                if(::IceInternal::upCast((*_i0).loc.get())->__usesClasses())
                {
                    ::IceInternal::upCast((*_i0).loc.get())->__decRefUnsafe();
                    (*_i0).loc.__clearHandleUnsafe();
                }
                else
                {
                    (*_i0).loc = 0;
                }
            }
        }
    }
}

void
cvac::LabeledTrack::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    if(keyframesLocations.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::cvac::__writeFrameLocationList(__os, &keyframesLocations[0], &keyframesLocations[0] + keyframesLocations.size());
    }
    ::cvac::__write(__os, interp);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable::__write(__os);
#else
    ::cvac::Labelable::__write(__os);
#endif
}

void
cvac::LabeledTrack::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    ::cvac::__readFrameLocationList(__is, keyframesLocations);
    ::cvac::__read(__is, interp);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Labelable::__read(__is, true);
#else
    ::cvac::Labelable::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
cvac::LabeledTrack::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::LabeledTrack was not generated with stream support";
    throw ex;
}

void
cvac::LabeledTrack::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type cvac::LabeledTrack was not generated with stream support";
    throw ex;
}
#endif

class __F__cvac__LabeledTrack : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::cvac::LabeledTrack::ice_staticId());
        return new ::cvac::LabeledTrack;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__cvac__LabeledTrack_Ptr = new __F__cvac__LabeledTrack;

const ::Ice::ObjectFactoryPtr&
cvac::LabeledTrack::ice_factory()
{
    return __F__cvac__LabeledTrack_Ptr;
}

class __F__cvac__LabeledTrack__Init
{
public:

    __F__cvac__LabeledTrack__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::cvac::LabeledTrack::ice_staticId(), ::cvac::LabeledTrack::ice_factory());
    }

    ~__F__cvac__LabeledTrack__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::cvac::LabeledTrack::ice_staticId());
    }
};

static __F__cvac__LabeledTrack__Init __F__cvac__LabeledTrack__i;

#ifdef __APPLE__
extern "C" { void __F__cvac__LabeledTrack__initializer() {} }
#endif

void 
cvac::__patch__LabeledTrackPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::cvac::LabeledTrackPtr* p = static_cast< ::cvac::LabeledTrackPtr*>(__addr);
    assert(p);
    *p = ::cvac::LabeledTrackPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::cvac::LabeledTrack::ice_staticId(), v->ice_id());
    }
}
