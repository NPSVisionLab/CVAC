'''
Generate ROC curve with Bag-of-Words algorithm.
Among optimal operating points, 
the best point and the corresponding detectorData will be returned  
generated by matz 7/16/2013
updated by k.lee May/2014
'''

import easy
import cvac
import time #for computing computation time
import os   #for chdir
stime = time.clock()

'''
Making training data
'''
#trainImg_roc_simple
#trainImg_roc
trainsetPos = easy.createRunSet( 'corporate_logos' )
trainsetNeg = easy.createRunSet( 'trainImg' )
 
runset = cvac.RunSet()
easy.addToRunSet(runset, trainsetPos, 'pos')
easy.addToRunSet(runset, trainsetNeg, 'neg')
easy.printRunSetInfo( runset, printLabels=True, )

strTrainer = "BOW_Trainer"
strDetector = "BOW_Detector"

list_nWord = [5,10,15,20]


doWithNegativeSample = True

if doWithNegativeSample:
    ###############################################################
    # With background data
    '''
    Execute jousting for generating ROC points
    '''
    contenders = []
    for nWord in list_nWord:
        c1 = evaluate.Contender("bowROC_binary_"+str(nWord))
        c1.trainerString = strTrainer
        c1.detectorString = strDetector
        trainer = easy.getTrainer(c1.trainerString)
        trainerProps = easy.getTrainerProperties(trainer)    
        trainerProps.props["NumWords"] = str(nWord)
        c1.trainerProps = trainerProps
        c1.foundMap = {'1':easy.getPurpose('pos'), '0':easy.getPurpose('neg')}
        contenders.append(c1)
        
    sortedperfdata, perfdata = evaluate.joust( contenders, runset, folds=3 )
    easy.showROCPlot(perfdata)
    '''
    Extract only optimal ROC points
    '''
    rocData_full,optimalIndices = easy.discardSuboptimal(perfdata)
    #rocData_full,optimalIndices = easy.discardSuboptimal(perfdata,"sboxes/BOW_Trainer_127_0_0_1")
    
    
    '''
    Prepare detector data of optimal ROC points
    ''' 
    rocData_optimal = []
    for idx in optimalIndices:
        trainer = contenders[idx].getTrainer()
        detectorData = easy.train( trainer, runset, \
                                   trainerProperties=contenders[idx].trainerProps )
        rocData_optimal.append([detectorData,\
                                rocData_full[idx][0],rocData_full[idx][1],\
                                rocData_full[idx][2]])
    '''
    ROC zip
    '''
    rocZip = easy.makeROCdata(rocData_optimal)
    
    '''
    Extract only optimal ROC points
    '''
    detector = easy.getDetector( strDetector )
    detectorProps = easy.getDetectorProperties(detector)
    #specify either a desired falseAlarmRate or recall, but not both:
    priority = "recall"
    if priority=="falseAlarmRate":
        detectorProps.falseAlarmRate = 0.01 #x-axis
        print("falseAlarmRate = {0}".format(detectorProps.falseAlarmRate))
    else:
        detectorProps.recall = 0.90 #y-axis
        print("recall = {0}".format(detectorProps.recall))
    results = easy.detect( detector, rocZip, runset, detectorProperties = detectorProps)
    easy.printResults( results )
else:
    ###############################################################
    # Without background data
    '''
    Execute jousting for generating ROC points
    '''
    contenders = []
    for nWord in list_nWord:
        c1 = evaluate.Contender("bowROC_oneclass_"+str(nWord))
        c1.trainerString = strTrainer
        c1.detectorString = strDetector
        trainer = easy.getTrainer(c1.trainerString)
        trainerProps = easy.getTrainerProperties(trainer)
        trainerProps.props["RejectClassStrategy"] = "ignore"    
        trainerProps.props["NumWords"] = str(nWord)
        c1.trainerProps = trainerProps
        c1.foundMap = {'1':easy.getPurpose('pos'), '0':easy.getPurpose('neg')}
        contenders.append(c1)
        
    sortedperfdata,perfdata = evaluate.joust( contenders, runset, folds=3 )
    
    
    '''
    Extract only optimal ROC points
    '''
    rocData_full,optimalIndices = easy.discardSuboptimal(perfdata)
    #rocData_full,optimalIndices = easy.discardSuboptimal(perfdata,"sboxes/BOW_Trainer_127_0_0_1")
    
    
    '''
    Prepare detector data of optimal ROC points
    ''' 
    rocData_optimal = []
    for idx in optimalIndices:
        trainer = contenders[idx].getTrainer()
        detectorData = easy.train( trainer, runset, \
                                   trainerProperties=contenders[idx].trainerProps )
        rocData_optimal.append([detectorData,\
                                rocData_full[idx][0],rocData_full[idx][1]])
    '''
    ROC zip
    '''
    rocZip = easy.makeROCdata(rocData_optimal)
    
    '''
    Extract only optimal ROC points
    '''
    opPoints = easy.getSensitivityOptions(rocZip)
    print("The ROC model has the following sensitivities")
    for op in opPoints:
        print("False alarm rate {0}, Recall {1}".format(op[0], op[1]))
    detector = easy.getDetector( strDetector )
    detectorProps = easy.getDetectorProperties(detector)
    #specify either a desired falseAlarmRate or recall, but not both:
    priority = "recall"
    if priority=="falseAlarmRate":
        detectorProps.falseAlarmRate = 0.01 #x-axis
        print("falseAlarmRate = {0}".format(detectorProps.falseAlarmRate))
    else:
        detectorProps.recall = 0.90 #y-axis
        print("recall = {0}".format(detectorProps.recall))
    results = easy.detect( detector, rocZip, runset, detectorProperties = detectorProps)
    easy.printResults( results )

etime = time.clock()
print('Time='+str(etime-stime))

